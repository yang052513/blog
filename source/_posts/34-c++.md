---
title: COMP3522 C++ Notes
date: 2020-08-28 14:23:43
tags: ['c++', 'programming', 'notes']
categories: Notes
cover: 'https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/6038586442907648.png?alt=media&token=e6fd07e9-bb9a-45ab-999f-256e874132fa'
---

# COMP3522 C++ Practice Midterm

## PART A: Theory

### 1. What is a copy constructor? When is it used? Be specific. Code snippets may be used as an example

A copy constructor is when an object is intilized with another object that passed to. It's used when we want to copy all the members to another object. For example below, we created `hero1` object, and invoke copy constructor for `hero2` object. `hero1` and `hero2` are now all have same `strength` value. However, by invoking default copy constructor, we find that both `hero1` and `hero2` are pointing to same memory address which lead to shallow copy problem.

```c++
class Hero {
private:
    double strength;
public:
    Hero(double strength) {
        this->strength = strength;
    }
    double getStrength() {
        return strength;
    }
}

int main() {
    Hero hero1(87.0);
    Hero hero2 = hero1;
    std::cout << hero1.getStrength() << " " << &hero1 << std::endl;
    std::cout << hero2.getStrength() << " " << &hero2 << std::endl;
    return 0;
}
```

### 2. What is a reference? How is it different from a pointer?

A reference is an alias which can be used to refer an existing object. A pointer is a variable that holds the memory address of another variable. However, unlike pointer we can initialized with `nullptr`, we need to initaized reference before created.

```c++
int main() {
    string food = "Ramen";
    string *food2; // init with null ptr
    food2 = &food; // point to food
    string &food3 = food; // food reference called food3

    food3 = "Burger";
    *food2 = "Chicken";

    cout << food << " " << "Memory address: " << &food << endl;
    cout << *food2 << " " << "Memory address: " << food2 << endl;
    cout << food3 << " " << "Memory address: " << &food3 << endl;
}
```

### 3. In C++, we may pass arguments to functions by value, by pointer, or by reference. What is the difference? Why would we choose one over the other?

- Pass arguments by value will create a copy of the value and pass to the functions, which doesnt impact the original value
- Pass by pointer which will pass the variable that holds the memory address
- Pass by reference will pass the same variable that referred to, which has same memory location

```c++
void swapByValue(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

void swapByPointer(int *a, int *b) {
    int temp = *a; // create variable temp holds a address
    *a = *b;  // swap address
    *b = temp;
}

void swapByReference(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}


int main() {
    int n1 = 5;
    int n2 = 12;

    swapByValue(n1, n2);
    swapByPointer(&n1, &n2);
    swapByReference(n1, n2);
    return 0;
}

```

### 4. Suppose we have a C++ string called success. What is the difference between `&success` and `success&`? When would we use each of these?

`&success` is the memory address of string success. `success&` is used to pass string `success` as a reference to function

### 5. What is the difference between static allocation and dynamic allocation? You may provide code snippets to help illustratet the difference.

**Static allocation**

- the memory of variable is allocated permanently when the program compiled
- `int i = 10;`

**Dynamic allocation**

- The programmer now manage the memory allocation by using `new` and `delete` operators to allocate and free memory
- `int *p = new int;`

### 6. What is a memory leak? How do we prevent memory leaks in C++? Write a short function to demonstrate code that generates a memory leak, and then insert and underline some code that plugs the leak.

A memory leak is when a programmers allocates memory using `new` keyword but not deallocate the memory.

```c++
void memoryLeak() {
    // allocate memory
    int * ptr = new int(5);

    // deallocate
    delete ptr;
}

int main() {
    memoryLeak();
    return 0;
}
```

### 7. With respect to the `const` keyword

#### a. What is the purpose of making an argument to a function const?

When making an parameter to a const the parameter only applies locally within the function.

#### b. What is the purpose of returning something that is const from a function?

Returning something that is const could prevent some cases the non-const operation perfrom to the function

#### c. What is the purpose of adding the const keyword to a function header?

The purpose is to not allow the function modify the object passed when they are invoked.

### 8. We rarely invoke an object's destructor directly. When is an object's destructor invoked for us?

A destructor is a member function that is invoked automatically when the object **goes out of scope** or is explicitly destoryed by a call to `delete`

### 9. How can we use the sizeof operator to determine the length of a statically allocated array? Why wont this work with an array created in the heap/free store?

```c++
int arr[13];
std::cout << (sizeof arr) / (sizeof *arr);
```

### 10. There are three ways to initialize variables in C++. What are they, and which method od we prefer to use? Why?

1. C-like initialization `int a = 3;`
2. Constructor initialization `intx(0);`
3. Uniform initialization `int a {3};`

We prefer to use uniform initialization because it prevents narrow conversion

### 11. When do we use the scope operator `::` and when do we use the dot operator `.` in C++

The dot operator `.` is used to access **members of an object**. The scope operator `::` is used to access members of a namespace or a class

### 12. Only one fundamental type in C++ has fixed size. Which type is it, and how big is it?

`char` 1 byte

### 13. What is the difference between the class and the struct in C++?

`struct` and `class` are almost identical except the access modifiers in class default is `private` and `public` in struct

### 14. What is an inline function? What is the advantage of an inline function? How do we designate that a function is inline?

Inline function instruct compiler to insert complete body of the function wherever that function got used in code, which does not require function calling overhead.

```c++
inline int increment(int x) {
    return ++x;
}

int main() {
    std::cout << increment(3);
    return 0;
}
```

### 15. What is forward declaration and what is its purpose?

**Forward Declaration** refers to the beforehand declaration of the syntax or signature of an identifies, variable, function, class... prior to its usage. Usually used for Classes

```c++
// forward declaration
void increment(int n1);

// implementation
void increment(int n1) {
    std::cout << n1;
}

```

### 16. How do we make a class abstract in C++?

A class is made abstract by declaring at least one of its function as **pure virtual function**. A pure virtual function is specified by placing `=0` in its declaration

```c++
class Shape {
public:
    virtual int getArea() = 0;
protected:
    int width;
    int height;
}

class Rectangle: public Shape {
public:
    int getArea() {
        return width * height;
    }
}
```

### 17. Does C++ have interfaces? Explain

C++ does not have built in interface like Java and other language does. However, we could implement it using abstract class by using pure virtual functions.

### 18. In C++, multiple inheritance may result in a class diamond-shaped inheritance pattern.

#### a. How does this happen?

The diamond problem occurs when two superclasses of a class have a common base class.

#### b. Does this cause any ambiguities with respect to member functions? How can the ambiguities be solved?

```c++
class Person {
public:
    Person(int x) { cout << "Person class called" };
}

class Faculty: virtual public Person {
public:
    Faculty(int x):Person(x) { cout << "Faculty class called" }
}

class Student: virtual public Person {
public:
    Student(int x):Person(x) {cout << "Student class called" }
}

class TA: public Faculty, public Student {
public:
    TA(int x):Student(x), Faculty(x), Person(x) { cout << "TA called" }
}
```

### 19. When we implement the assignment operator, we use the copy and swap algorithm. How does the copy and swap algorithm work? Can you identify an easy way to introduce an error into a copy and swap function

```c++
void swap(Matrix &m1, Matrix &m2) {
    using std::swap;
    swap(m1.matrix, m2.matrix);
}

Matrix& Matrix::operator=(Matrix m) {
    swap(*this, m);
    return *this;
}
```
