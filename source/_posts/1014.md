---
title: 1014. Best Sightseeing Pair
date: 2021-02-07 11:02:28
tags: ["Leetcode", "Algorithm", "Medium", "Dynamic Programming"]
comments: false
categories: "Leetcode"
cover: "https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/0_zuhXdNAIUoxEem4-.jpeg?alt=media&token=f1f7a5cb-3eea-46ee-b450-7e75d9c28447"
---

# 1014. Best Sightseeing Pair

Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.

The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

## 示例

### 示例 1:

```code
Input: [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11
```

## 提示:

- 2 <= A.length <= 50000
- 1 <= A[i] <= 1000

## Solutions

### 1. 暴力求解 (超时)

先看下用暴力求解的方法解决这个问题.

暴力求解我们只需要固定一个点, 然后从这个点的右侧遍历一直算每对`(i, j)`的评分, 最后返回最高的评分即可.

```c++
class Solution {
public:
    int maxScoreSightseeingPair(vector<int>& A) {
        int res = 0;

        for (int i = 0; i < A.size()-1; i++) {
            for (int j = i+1; j < A.size(); j++) {
                res = max(res, A[i]+A[j]+i-j);
            }
        }
        return res;
    }
};
```

### 2. 动态规划

评分的公式为 `A[i] + A[j] + i - j`, 换一下位置得到 `(A[i] + i) + A[j] - j)`.

`A[j]-j`也就是当前元素减去它自己下标.

在之前的暴力求解中, 第二个循环有很多重复的`A[j]-j`的计算. 比如从`8`开始遍历, `1,5,2,6`的`A[j]-j`都已经求过了. 但到了遍历`1`的时候, 又去重新计算`5,2,6`的`A[j]-j`.

由于题目要求`i < j`所以`i`的观赏点必须在`j`的左边.

因此我们可以用动态规划的思想来优化这个问题, 我们用一个变量`max_i`来记录最大的`A[i]+i`. 每次遍历元素先判断当前元素与`max_i`组成的评分是否为最大, 然后对比当前元素与`max_i`看当前元素是否为更好观赏点 i. 因为 i 的下标与评分成正比, 所以我们需要最大化`A[i]+i`.

```c++
class Solution {
public:
    int maxScoreSightseeingPair(vector<int>& A) {
        int res = 0;
        int max_i = A[0];

        for (int i = 1; i < A.size(); i++) {
            res = max(res, max_i + A[i] - i);
            max_i = max(max_i, A[i]+i);
        }
        return res;
    }
};
```
