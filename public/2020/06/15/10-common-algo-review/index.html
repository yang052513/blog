<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Algorithim 概览 | Yang's Blog</title><meta name="description" content="总结下暑假算法课中学习到的知识点，代码主要以 python 和 typescript 来展示。  Sorting Algorithim 排序算法Brute Force 暴力求解 从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1"><meta name="keywords" content="notes,algorithim,bcit"><meta name="author" content="Yang Li"><meta name="copyright" content="Yang Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/yang-favicon.png"><link rel="canonical" href="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Algorithim 概览"><meta property="og:url" content="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/"><meta property="og:site_name" content="Yang's Blog"><meta property="og:description" content="总结下暑假算法课中学习到的知识点，代码主要以 python 和 typescript 来展示。  Sorting Algorithim 排序算法Brute Force 暴力求解 从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1"><meta property="og:image" content="https://3.bp.blogspot.com/-bsAe5iHfUvw/XMm2l8YCMtI/AAAAAAAAA28/9-Uj-v3GHhIE06c1_HdSEOeXML1byHInACLcBGAs/s1600/what-is-an-algorithm.png"><meta property="article:published_time" content="2020-06-15T07:55:19.000Z"><meta property="article:modified_time" content="2020-06-20T07:08:46.099Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="ES6与Javascrpit的对比" href="https://yangblog.netlify.app/2020/06/17/11-es6-notes/"><link rel="next" title="自定义Windows10下的terminal外观" href="https://yangblog.netlify.app/2020/06/15/09-customize-powershell/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Yang Li","link":"链接: ","source":"来源: Yang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/yang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Sorting-Algorithim-排序算法"><span class="toc-number">1.</span> <span class="toc-text">Sorting Algorithim 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-暴力求解"><span class="toc-number">1.1.</span> <span class="toc-text">Brute Force 暴力求解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorting"><span class="toc-number">1.1.1.</span> <span class="toc-text">Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bubble-Sort-冒泡排序"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Bubble Sort 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selection-Sort-选择排序"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Selection Sort 选择排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Match-字符串匹配"><span class="toc-number">1.1.2.</span> <span class="toc-text">String Match 字符串匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Knapsack-Problem-背包问题"><span class="toc-number">1.1.3.</span> <span class="toc-text">Knapsack Problem 背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decrease-and-Conquer-减治法"><span class="toc-number">1.2.</span> <span class="toc-text">Decrease and Conquer 减治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insertation-Sort-插入排序"><span class="toc-number">1.2.1.</span> <span class="toc-text">Insertation Sort 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search-and-Binary-Tree-二分查找与二叉树"><span class="toc-number">1.2.2.</span> <span class="toc-text">Binary Search and Binary Tree 二分查找与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Tree"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Tree-Traversal-二叉树遍历"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Binary Search Tree Traversal 二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Pre-order-Traversal-前序遍历"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">Pre-order Traversal 前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#In-order-Traversal-中序遍历"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">In-order Traversal 中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Post-order-Traversal-后序遍历"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">Post-order Traversal 后序遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Divide-and-Conquer-分治法"><span class="toc-number">1.3.</span> <span class="toc-text">Divide and Conquer 分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Sort-归并排序"><span class="toc-number">1.3.1.</span> <span class="toc-text">Merge Sort 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quick-Sort-快速排序"><span class="toc-number">1.3.2.</span> <span class="toc-text">Quick Sort 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最近点对-Cloest-Pair-Problem"><span class="toc-number">1.3.3.</span> <span class="toc-text">最近点对 Cloest Pair Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transform-and-Conquer-变治法"><span class="toc-number">1.4.</span> <span class="toc-text">Transform and Conquer 变治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Instance-Simplification-Pre-sorting-预排序"><span class="toc-number">1.4.1.</span> <span class="toc-text">Instance Simplification Pre-sorting 预排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Check-Elements-Uniqueness-判断元素是否独特性"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Check Elements Uniqueness 判断元素是否独特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Find-the-Mode-寻找众数"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Find the Mode 寻找众数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representation-Change"><span class="toc-number">1.4.2.</span> <span class="toc-text">Representation Change</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-堆"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Heap 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Complete-Binary-Tree-完全二叉树"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">Complete Binary Tree 完全二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Heap-Construction-堆的构建"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">Heap Construction 堆的构建</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-Insert-堆的插入"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Heap Insert 堆的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-Delete-堆的删除"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">Heap Delete 堆的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-Sort-堆排序"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">Heap Sort 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分析"><span class="toc-number">1.4.2.4.2.</span> <span class="toc-text">分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary-of-sorting-algorithms"><span class="toc-number">1.5.</span> <span class="toc-text">Summary of sorting algorithms</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://3.bp.blogspot.com/-bsAe5iHfUvw/XMm2l8YCMtI/AAAAAAAAA28/9-Uj-v3GHhIE06c1_HdSEOeXML1byHInACLcBGAs/s1600/what-is-an-algorithm.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Yang's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Algorithim 概览</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-15 00:55:19"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-20 00:08:46"><i class="fas fa-history fa-fw"></i> 更新于 2020-06-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>总结下暑假算法课中学习到的知识点，代码主要以 python 和 typescript 来展示。</p>
</blockquote>
<h1 id="Sorting-Algorithim-排序算法"><a href="#Sorting-Algorithim-排序算法" class="headerlink" title="Sorting Algorithim 排序算法"></a>Sorting Algorithim 排序算法</h1><h2 id="Brute-Force-暴力求解"><a href="#Brute-Force-暴力求解" class="headerlink" title="Brute Force 暴力求解"></a>Brute Force 暴力求解</h2><blockquote>
<p>从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1 次猜中，但最坏的情况<code>Worst case</code>就是 10 次。</p>
</blockquote>
<p>然而，暴力求解的算法并不是最有效的，在之后的算法<code>Divide and conquer</code>中，我们可以猜 0，然后递增到 5。根据给出的结果再进行猜测会大大提高效率。</p>
<a id="more"></a>

<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><p>暴力求解排序方法主要讲解冒泡排序和选择排序</p>
<h4 id="Bubble-Sort-冒泡排序"><a href="#Bubble-Sort-冒泡排序" class="headerlink" title="Bubble Sort 冒泡排序"></a>Bubble Sort 冒泡排序</h4><blockquote>
<p>假设我们有一个可排序的数组, 冒泡排序即从第一个元素开始，每个元素进行两两比较。如果左边的大于右边的,就进行位置替换。完成第一个 iteration 之后继续从第二个元素开始进行相同的步骤。</p>
</blockquote>
<p>根据定义，我们的伪代码如下:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to A.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to A.length - <span class="number">1</span> -i</span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            swap(left, right)</span><br></pre></td></tr></table></figure>

<p>比如我们有一个数组<code>[3, 0, 6, 1]</code>。那我们先从第一位<code>3</code>开始， 先是<code>3</code>和<code>0</code>比较，<code>3</code>大于<code>0</code>于是我们进行调换。比较完成后我们递增到下一位继续进行两两比较</p>
<p>现在数组为<code>[0, 3, 6, 1]</code>。于是我们继续进行比较<code>3</code>和<code>6</code>。很明显<code>3</code>小于<code>6</code>，我们不需要进行调换。我们来到最后一组比较<code>6</code>和<code>1</code>。左边大于右边我们进行调换。</p>
<p>此时我们第一个 iteration 的排序完成了, <code>[0, 3, 1, 6]</code>。</p>
<p>同理我们现在从<code>index=1</code>的位置开始进行以上相同的步骤直到结束。</p>
<p>如此我们可以写出冒泡排序的代码</p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span> -i):</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>]):</span><br><span class="line">                array[j], array[j+<span class="number">1</span>] = array[j+<span class="number">1</span>], array[j]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<p><strong>Typescrtipt</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n: <span class="built_in">number</span> = list.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[j] &gt; list[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        ;[list[j], list[j + <span class="number">1</span>]] = [list[j + <span class="number">1</span>], list[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看出，冒泡排序有两个 for 循环，我们可得出复杂度 Big Oh 为 n 的平方</p>
<h4 id="Selection-Sort-选择排序"><a href="#Selection-Sort-选择排序" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h4><p>选择排序的方法是我们首先设定第一个字符的元素为最小值，然后我们进行数组的循环。如果我们在 iteration 中发现有元素比当前设定的元素小，我们将该元素设置为新的最小值。重复步骤结束 iteration 并把此循环中最小值起始的值替换完成排序。伪代码如下:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to Array.length -<span class="number">1</span>:</span><br><span class="line">    min = i</span><br><span class="line">    <span class="keyword">for</span> j = i+<span class="number">1</span> to Array.length:</span><br><span class="line">        <span class="keyword">if</span>(j &lt; min):</span><br><span class="line">            min = j</span><br><span class="line">    swap(i, j)</span><br></pre></td></tr></table></figure>

<p>因为暴力求解每个元素进行比较，所以我们用一个简单的数组举例…</p>
<p>假设我们用选择排序算法来排序<code>[3, 0, 2]</code>数组。</p>
<p>首先把最小值<code>min</code>设置为<code>array[0]</code>也就是<code>3</code>, 然后<code>i+1</code>开始进行判断，<code>0</code>小于<code>3</code>。好我们现在把<code>min</code>设置为<code>0</code>然后继续前进。</p>
<p><code>2</code>大于<code>0</code>，我们跳过。于是第一个循环完成了。我们进行<code>i</code>和更新后的最小值<code>min</code>调换得到</p>
<p><code>[0, 3, 2]</code>。</p>
<p>OK, 同理我们从<code>i = 1</code>开始，<code>min</code>现在设置为<code>array[1]</code>也就是<code>3</code>。比较<code>3</code>和<code>2</code>条件成立进行 swap。</p>
<p>最后我们得到<code>[0, 2, 3]</code></p>
<p>选择排序代码如下</p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[min]):</span><br><span class="line">                min = j</span><br><span class="line">        array[i], array[min] = array[min], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<p><strong>Typescript</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = array.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = i</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</span><br><span class="line">        min = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ;[array[i], array[min]] = [array[min], array[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-Match-字符串匹配"><a href="#String-Match-字符串匹配" class="headerlink" title="String Match 字符串匹配"></a>String Match 字符串匹配</h3><p>回到最开始的搜索内容查询位置问题。用暴力求解的方法也写的话，我们就要每个字符开始进行比较。一旦有一个字符不匹配我们位移一个单位继续进行判断。</p>
<p>比如我们要在<code>I love python</code>中搜索<code>python</code>。首先从<code>I</code>开始进行匹配，直到<code>index = 7</code>的位置才匹配成功并返回<code>index = 7</code>。</p>
<p>伪代码如下:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to n - m:</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    while j &lt; m and pattern[j] = text[i + j] <span class="keyword">do</span></span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(j = m):</span><br><span class="line">        return i</span><br><span class="line">return -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Knapsack-Problem-背包问题"><a href="#Knapsack-Problem-背包问题" class="headerlink" title="Knapsack Problem 背包问题"></a>Knapsack Problem 背包问题</h3><p>背包问题即给定一些特定物品并有对应的价格和重量。然后有一个限重 W 的背包，每个物品只能选择一次。在不超重的情况下如何做到价值最大化选择？</p>
<p>举个简单的例子。我们有一个最重承受 10kg 的背包。并有以下物品可以选择: 物品一: 2kg, 10 元。 物品二: 5kg, 30 元。物品三: 4kg, 20 元….如此。</p>
<p>暴力算法来解决这个问题就是将所有可能的组合先全部列出来，然后判断并筛选超重的集合，最后比较所有集合来找到价值最高的集合。</p>
<p>算法效率来讲，假设我们有 n 个物品，那复杂度即为 2 的 n 次方</p>
<h2 id="Decrease-and-Conquer-减治法"><a href="#Decrease-and-Conquer-减治法" class="headerlink" title="Decrease and Conquer 减治法"></a>Decrease and Conquer 减治法</h2><p>这个 section 我们引入减治法。跟暴力求解不同，减治法通过逐步缩小问题规模来解决一个问题。简而言之，回到我们之前猜数字的游戏。如果用暴力求解，我们要一个数字一个数字猜测。减治法可以先把数字对半分，比如猜从 0-10 的数字，我们可以先拆成 0-5 和 6-10。如果我们给出 5 系统显示太高，那我们可以继续对半拆除从 0-4 进行同样的步骤。直到最后我们找到数字也就是一直拆分问题。</p>
<h3 id="Insertation-Sort-插入排序"><a href="#Insertation-Sort-插入排序" class="headerlink" title="Insertation Sort 插入排序"></a>Insertation Sort 插入排序</h3><p>假设我们一个数组<code>[0, 1, 5, 3, 2]</code>。第一部分<code>[0, 1]</code>是有序数列，后半部分为无序数列。也就是说我们每次只要把无序数列的第一个元素插入到正确的位置后，整体问题的规模就减少 1。如果我们重复<code>n-1</code>此后，数组也重新排成有序了。</p>
<blockquote>
<p>重复 n-1 是因为只有一个元素的数组必定是有序的。</p>
</blockquote>
<p>可以把插入排序想象成扑克牌卡片排序。</p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        index = array[i]</span><br><span class="line">        <span class="comment"># the index in the left of i</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果左边还有数字 并且 当前元素小于它左边的元素：</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; array[j]:</span><br><span class="line">            <span class="comment"># 调换当前元素和左边的元素</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]</span><br><span class="line">            <span class="comment"># 继续向左移动</span></span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束 插入到对应的位置</span></span><br><span class="line">        array[j + <span class="number">1</span>] = index</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<p><strong>Typescript</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n: <span class="built_in">number</span> = array.length</span><br><span class="line">  <span class="comment">//起始为1 因为第一个是有序的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = array[i]</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; index &lt; array[j]) &#123;</span><br><span class="line">      array[j + <span class="number">1</span>] = array[j]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    array[j + <span class="number">1</span>] = index</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以看出我们有 2 个循环，所以插入排序的复杂度为 n 的平方</p>
<h3 id="Binary-Search-and-Binary-Tree-二分查找与二叉树"><a href="#Binary-Search-and-Binary-Tree-二分查找与二叉树" class="headerlink" title="Binary Search and Binary Tree 二分查找与二叉树"></a>Binary Search and Binary Tree 二分查找与二叉树</h3><h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><p>目前我们涉及到的算法都是从数组的第一个位置开始然后进行查找。二分查找则从一个数组的中间开始，从左往右一次查找，直到找到该元素或循环结束</p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(array, key)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(array) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == array[m]:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">elif</span> key &lt; array[m]:</span><br><span class="line">            r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>Typescript</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">array, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> l: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> r: <span class="built_in">number</span> = array.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor((<span class="number">1</span> + r) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (key === array[m]) &#123;</span><br><span class="line">      <span class="keyword">return</span> m</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; array[m]) &#123;</span><br><span class="line">      r = m - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = m + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h4><p>将数组(有序)分为两部分，数组的中间元素为树的根节点，左边和右边的元素再进行相同的划分，小于根节点的元素放在左边，大于的再右边。</p>
<h4 id="Binary-Search-Tree-Traversal-二叉树遍历"><a href="#Binary-Search-Tree-Traversal-二叉树遍历" class="headerlink" title="Binary Search Tree Traversal 二叉树遍历"></a>Binary Search Tree Traversal 二叉树遍历</h4><p>根据二叉搜索树我们可以进行数组的插入，查询和删除节点。接下来我们引入二叉树遍历即怎样直到节点是否已经被访问过了。</p>
<h5 id="Pre-order-Traversal-前序遍历"><a href="#Pre-order-Traversal-前序遍历" class="headerlink" title="Pre-order Traversal 前序遍历"></a>Pre-order Traversal 前序遍历</h5><h5 id="In-order-Traversal-中序遍历"><a href="#In-order-Traversal-中序遍历" class="headerlink" title="In-order Traversal 中序遍历"></a>In-order Traversal 中序遍历</h5><h5 id="Post-order-Traversal-后序遍历"><a href="#Post-order-Traversal-后序遍历" class="headerlink" title="Post-order Traversal 后序遍历"></a>Post-order Traversal 后序遍历</h5><h2 id="Divide-and-Conquer-分治法"><a href="#Divide-and-Conquer-分治法" class="headerlink" title="Divide and Conquer 分治法"></a>Divide and Conquer 分治法</h2><blockquote>
<p>分治法的理论为把一个大的问题分成若干个小问题，然后逐个解决小问题，最后将小问题的解决方案合并到原来大问题的解。比如乐高玩具，一个乐高模型分成若干个小问题即乐高零件。小问题的解就是将各个组件先拼好，比如房顶，门之类。最后解决完整的模型。</p>
</blockquote>
<p>在介绍归并排序之前，我们先来了解以下有序数组的合并。我们可以把将两个有序数组的合并看作为解决一个小问题。最终合并所有数组即能解决原本的问题。</p>
<p>我们有两个有序数组<br>a： <code>[2, 3, 8, 9]</code><br>b: <code>[1, 4, 5, 7]</code></p>
<p>假设我们现在需要把 a 和 b 合并为一个新的有序数组到一个空的 c <code>[]</code></p>
<ul>
<li>首先我们用三个变量分别来记录三个数组的索引值并初始化为 0， 数组 1 为<code>i</code>， 数组 2 为<code>j</code>，数组 3 为<code>k</code></li>
<li>然后我们比较 a[i]和 b[i]并将较小的元素存入到数组<code>c[0]中</code>。初始化为 0，所以我们比较<code>a[0]</code>和<code>b[0]</code>。</li>
<li>之后我们将较小元素的数组索引值和数组 c 的索引值加 1<ul>
<li>然后我们继续重复第二步进行比较</li>
</ul>
</li>
</ul>
<p>最好的情况下我们要比较 n/2 个元素，最坏的情况要比较 n - 1 次。由此可以得到合并有序数组的复杂度为 n</p>
<h3 id="Merge-Sort-归并排序"><a href="#Merge-Sort-归并排序" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h3><p>考完试再更新吧 先了解以下</p>
<p>复杂度 nlogn</p>
<h3 id="Quick-Sort-快速排序"><a href="#Quick-Sort-快速排序" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h3><blockquote>
<p>Lumuto 划分：首选选一个中间值来作为我们的中轴(pivot), 所有比中轴值小的元素位于中轴的左侧，而大于中轴值的元素位于中轴的右侧。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(array) - <span class="number">1</span></span><br><span class="line">    pivot = a[l]</span><br><span class="line">    s = l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>, r+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; p:</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            a[s], a[i] = a[i], a[s]</span><br><span class="line">            a[l], a[s] = a[s], a[l]</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h3 id="最近点对-Cloest-Pair-Problem"><a href="#最近点对-Cloest-Pair-Problem" class="headerlink" title="最近点对 Cloest Pair Problem"></a>最近点对 Cloest Pair Problem</h3><h2 id="Transform-and-Conquer-变治法"><a href="#Transform-and-Conquer-变治法" class="headerlink" title="Transform and Conquer 变治法"></a>Transform and Conquer 变治法</h2><h3 id="Instance-Simplification-Pre-sorting-预排序"><a href="#Instance-Simplification-Pre-sorting-预排序" class="headerlink" title="Instance Simplification Pre-sorting 预排序"></a>Instance Simplification Pre-sorting 预排序</h3><h4 id="Check-Elements-Uniqueness-判断元素是否独特性"><a href="#Check-Elements-Uniqueness-判断元素是否独特性" class="headerlink" title="Check Elements Uniqueness 判断元素是否独特性"></a>Check Elements Uniqueness 判断元素是否独特性</h4><p>给出一个数组，判断是否该数组存在重复元素。</p>
<p>我们先用暴力求解来看下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique_bf</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 存储当前索引元素变量</span></span><br><span class="line">        index_value = array[i]</span><br><span class="line">        <span class="comment"># 循环数组 查找是否有匹配相等的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(array[j] == index_value):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>由上可以可以得出复杂度为 n 的平方。</p>
<p>假设我们先将数组进行排序得到一个有序数组，然后在进行判断是否存在重复元素。因为一个有序数组，我们只要查看一个元素是否跟它的下一个元素是否相等即可。比如<code>[2, 3, 3, 5]</code>。</p>
<p>用代码来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique_presort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="comment"># 假设我们先进行排序</span></span><br><span class="line">    array.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> array[i] == array[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>由于算法由两部分构成（排序和主循环），所以该其复杂度也应该为两部分：排序的复杂度加检查的复杂度。即为 nlogn + n。得到复杂度 nlogn</p>
<h4 id="Find-the-Mode-寻找众数"><a href="#Find-the-Mode-寻找众数" class="headerlink" title="Find the Mode 寻找众数"></a>Find the Mode 寻找众数</h4><p>众数是出现在一组数据中最频繁的数。这个算法在项目中应该算很常见，比如我最近在做的项目要涉及到计算出最常用的三个标签，或者使用频率最高的技能。</p>
<p>我们先来看下用暴力求解如何实现这个算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_mode</span><span class="params">(array)</span>:</span></span><br><span class="line">  n = len(array)</span><br><span class="line">  <span class="comment"># 统计每个数字的频率</span></span><br><span class="line">  counter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    counter[array[i]] = counter.get(array[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  occurence = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> counter.items():</span><br><span class="line">    <span class="keyword">if</span> value &gt; occurence:</span><br><span class="line">      occurence = value</span><br><span class="line">      mode = key</span><br><span class="line">  <span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure>

<p>最坏的情况下我们的数组每个元素都只出现一次 <code>[1, 2, 3, 4, 5, 6]</code>。复杂度为 n2</p>
<p>如果我们先将数组进行排序，那么相同的元素在有序数组里一定是相邻的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_mode_presort</span><span class="params">(array)</span>:</span></span><br><span class="line">    array.sort()  <span class="comment"># sort array</span></span><br><span class="line">    i = <span class="number">0</span>; freq = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(array):</span><br><span class="line">        temp_freq = <span class="number">1</span>; temp_mode = array[i]</span><br><span class="line">        <span class="keyword">while</span> i + temp_freq &lt; len(array) <span class="keyword">and</span> array[i+temp_freq] == temp_mode:</span><br><span class="line">            temp_freq += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp_freq &gt; freq:</span><br><span class="line">            freq = temp_freq; mode = temp_mode</span><br><span class="line">        i += temp_freq</span><br><span class="line">    <span class="keyword">return</span> mode</span><br><span class="line"></span><br><span class="line">array = [<span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">print(<span class="string">"The mode of the array is %d."</span> % compute_mode_presort(array))</span><br></pre></td></tr></table></figure>

<p>算法复杂度可以得出：O(nlog n) + O(log n) = O(nlog n)</p>
<h3 id="Representation-Change"><a href="#Representation-Change" class="headerlink" title="Representation Change"></a>Representation Change</h3><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h4><h5 id="Complete-Binary-Tree-完全二叉树"><a href="#Complete-Binary-Tree-完全二叉树" class="headerlink" title="Complete Binary Tree 完全二叉树"></a>Complete Binary Tree 完全二叉树</h5><p>堆一个完全二叉树，即除了最后一层的节点没有铺满外，其他层均已排满。</p>
<h5 id="Heap-Construction-堆的构建"><a href="#Heap-Construction-堆的构建" class="headerlink" title="Heap Construction 堆的构建"></a>Heap Construction 堆的构建</h5><p>我们把堆分为两种，一种是大顶堆(max heap)即数字越大的优先级越高，另一种为小顶堆(min heap)即数字越小的优先级越高。</p>
<p>我们以 max heap 为例，由于数字越大的优先级更高， 于是数字越大即优先级越高的数字就越靠近根节点的位置。</p>
<p>并且父节点的值总是大于或等于其子节点的值。</p>
<p>如何构建一个堆排序呢？</p>
<ul>
<li>首先我们将数组的元素以 binary tree 的形式表现出来。(无序不满足堆的性质)</li>
<li>然后从堆尾由上至下进行节点元素的调换。直到所有节点都满足堆的性质（即父节点的值总是大于或等于其子节点的值)</li>
</ul>
<blockquote>
<p>注: 父节点没有子节点时，左右的排序不需要满足右节点大于左节点（不同于二叉树搜索）</p>
</blockquote>
<p>//需要图片来描述步骤</p>
<h4 id="Heap-Insert-堆的插入"><a href="#Heap-Insert-堆的插入" class="headerlink" title="Heap Insert 堆的插入"></a>Heap Insert 堆的插入</h4><p>假设我们要把一个数值插入到一个堆中,如何来实现呢?</p>
<p>给定一个堆的排序 <code>[16, 15, 10, 14, 7, 9, 3, 2, 8 ,1]</code>，我们想要插入<code>17</code>到这个堆中</p>
<ul>
<li>首先我们把 17 放到数组的最后一个位置中</li>
<li>我们将 17 与它的父节点进行比较，也就是 7。7 小于 17 不满足堆的性质，于是我们进行调换 7 和 17 的位置</li>
<li>继续进行与父节点对比，17 和 15， 依旧不满足父节点大于子节点的的性质，我们调换 17 和 15 的位置</li>
<li>现在对比 17 和 16， 依然，我们进行调换。</li>
<li>重复以上步骤直到满足堆的性质</li>
</ul>
<blockquote>
<p>我们可以发现给定一个有 N 个元素的数组，堆的高度为 log2 为底 n 的对数。比如之前的例子，我们有 10 个元素，那堆的高度为 log2 10 = 3(向下取整)。根据堆得性质，我们发现插入一个元素到堆中需要进行堆的高度次元素。由此可得堆得算法复杂度为 log2 为底 n 的对数</p>
</blockquote>
<h4 id="Heap-Delete-堆的删除"><a href="#Heap-Delete-堆的删除" class="headerlink" title="Heap Delete 堆的删除"></a>Heap Delete 堆的删除</h4><p>从堆中删除一个元素的实现方法为：</p>
<ul>
<li>交换根节点的元素与堆尾的位置(数组中头尾交换)</li>
<li>删除堆尾</li>
<li>从上到下调整堆的结构（与堆的插入：由下至上相反）<ul>
<li>如果不满足堆的性质就交换两个节点的值</li>
</ul>
</li>
</ul>
<p>比如我们之前的例子，<code>[17, 16, 10, 14, 15, 9, 3, 2, 8, 1, 7]</code>。</p>
<p>我们想要删除节点 17。按照上面的步骤来实现即</p>
<ul>
<li>替换 17 与 7 的位置</li>
<li>删除 17</li>
<li>7 与 16 对比，不满足堆的性质调换位置</li>
<li>7 小于 15， 调换</li>
</ul>
<h4 id="Heap-Sort-堆排序"><a href="#Heap-Sort-堆排序" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>构建堆</li>
<li>堆顶和堆尾的值交换顺序，并删除交换后的堆尾元素</li>
<li>调整堆的结构（利用堆的删除方法，由上至下）</li>
<li>重复第二和第三步 直到堆为空</li>
</ul>
<p><a href="http://btv.melezinek.cz" target="_blank" rel="noopener">http://btv.melezinek.cz</a></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><h2 id="Summary-of-sorting-algorithms"><a href="#Summary-of-sorting-algorithms" class="headerlink" title="Summary of sorting algorithms"></a>Summary of sorting algorithms</h2><table>
<thead>
<tr>
<th>算法</th>
<th>最好的情况</th>
<th>最坏的情况</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>n2</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>n</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>n</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>n logn</td>
<td>n logn</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>n logn</td>
<td>n2</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>n logn</td>
<td>n logn</td>
<td>不稳定</td>
</tr>
</tbody></table>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Yang Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/">https://yangblog.netlify.app/2020/06/15/10-common-algo-review/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yangblog.netlify.app" target="_blank">Yang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/notes/">notes</a><a class="post-meta__tags" href="/tags/algorithim/">algorithim</a><a class="post-meta__tags" href="/tags/bcit/">bcit</a></div><div class="post_share"><div class="social-share" data-image="https://dynomapper.com/images/website_crawlers_banner.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/17/11-es6-notes/"><img class="prev-cover" data-src="https://miro.medium.com/max/840/0*Vbp13RW_9HpRqH6E.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ES6与Javascrpit的对比</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/15/09-customize-powershell/"><img class="next-cover" data-src="https://i1.wp.com/regroove.ca/wp-content/uploads/2018/08/powershell.png?fit=2560%2C1440&amp;ssl=1" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">自定义Windows10下的terminal外观</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/12/07-typescript/" title="Typescript 让你的Javascript更严谨"><img class="relatedPosts_cover" data-src="https://miro.medium.com/max/816/1*mn6bOs7s6Qbao15PMNRyOA.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-12</div><div class="relatedPosts_title">Typescript 让你的Javascript更严谨</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/14/08-your-first-npm-package/" title="如何创建你的第一个React组件库并发布到npm"><img class="relatedPosts_cover" data-src="https://www.itprotoday.com/sites/itprotoday.com/files/styles/article_featured_retina/public/github-npm.png?itok=NVoj-tk8"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-14</div><div class="relatedPosts_title">如何创建你的第一个React组件库并发布到npm</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/17/11-es6-notes/" title="ES6与Javascrpit的对比"><img class="relatedPosts_cover" data-src="https://miro.medium.com/max/840/0*Vbp13RW_9HpRqH6E.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-17</div><div class="relatedPosts_title">ES6与Javascrpit的对比</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/18/13-userRef-useReduce/" title="React常用Hooks笔记"><img class="relatedPosts_cover" data-src="https://www.educative.io/api/page/6018530514305024/image/download/5753173610332160"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-18</div><div class="relatedPosts_title">React常用Hooks笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/20/15-data-comm/" title="Intro to Data Communication and Networks"><img class="relatedPosts_cover" data-src="https://wallpaperplay.com/walls/full/b/1/e/42765.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-20</div><div class="relatedPosts_title">Intro to Data Communication and Networks</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/20/16-angular/" title="Learning Angular"><img class="relatedPosts_cover" data-src="https://www.freecodecamp.org/news/content/images/2020/04/Copy-of-Copy-of-Travel-Photography.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-20</div><div class="relatedPosts_title">Learning Angular</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://3.bp.blogspot.com/-bsAe5iHfUvw/XMm2l8YCMtI/AAAAAAAAA28/9-Uj-v3GHhIE06c1_HdSEOeXML1byHInACLcBGAs/s1600/what-is-an-algorithm.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Yang Li</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>