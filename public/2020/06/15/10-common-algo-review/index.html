<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Yang Li"><meta name="copyright" content="Yang Li"><meta name="generator" content="Hexo 4.2.1"><meta name="theme" content="hexo-theme-yun"><meta name="description" content="总结下暑假算法课中学习到的知识点，代码主要以 python 和 typescript 来展示。  Sorting Algorithim 排序算法Brute Force 暴力求解 从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithim 概览">
<meta property="og:url" content="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/index.html">
<meta property="og:site_name" content="Yang&#39;s Blog">
<meta property="og:description" content="总结下暑假算法课中学习到的知识点，代码主要以 python 和 typescript 来展示。  Sorting Algorithim 排序算法Brute Force 暴力求解 从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-15T07:55:19.000Z">
<meta property="article:modified_time" content="2020-06-19T07:47:00.352Z">
<meta property="article:author" content="Yang Li">
<meta property="article:tag" content="notes">
<meta property="article:tag" content="algorithim">
<meta property="article:tag" content="bcit">
<meta name="twitter:card" content="summary"><title>Algorithim 概览 | Yang's Blog</title><link rel="shortcut icon" href="/yang-favicon.png"><link rel="mask-icon" href="/yang-favicon.png" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"无名的小站","version":"0.7.2","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;family=Source+Code+Pro&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_4i778vmn3jg.js" async></script><div class="js-Pjax"></div><link rel="stylesheet" href="/css/prism-duotone-dark.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Yang Li"><img width="96" loading="lazy" src="/yang.jpg" alt="Yang Li"></a><div class="site-author-name"><a href="/about/">Yang Li</a></div><a class="site-name" href="/about/site.html">Yang's Blog</a><sub class="site-subtitle">I am very vegetable and poor</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">5</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">34</span></a></div><a class="site-state-item hty-icon-button" href="https://yun.yunyoujun.cn" target="_blank" rel="noopener" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/yang052513" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="liyang0525.ly@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/8399958" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我的后宫们" style="color:dodgerpurple"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="我的相册" style="color:dodgerpurple"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Sorting-Algorithim-排序算法"><span class="toc-number">1.</span> <span class="toc-text">Sorting Algorithim 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Brute-Force-暴力求解"><span class="toc-number">1.1.</span> <span class="toc-text">Brute Force 暴力求解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorting"><span class="toc-number">1.1.1.</span> <span class="toc-text">Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bubble-Sort-冒泡排序"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Bubble Sort 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selection-Sort-选择排序"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Selection Sort 选择排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Match-字符串匹配"><span class="toc-number">1.1.2.</span> <span class="toc-text">String Match 字符串匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Knapsack-Problem-背包问题"><span class="toc-number">1.1.3.</span> <span class="toc-text">Knapsack Problem 背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decrease-and-Conquer-减治法"><span class="toc-number">1.2.</span> <span class="toc-text">Decrease and Conquer 减治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insertation-Sort-插入排序"><span class="toc-number">1.2.1.</span> <span class="toc-text">Insertation Sort 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search-and-Binary-Tree-二分查找与二叉树"><span class="toc-number">1.2.2.</span> <span class="toc-text">Binary Search and Binary Tree 二分查找与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Tree"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Tree-Traversal-二叉树遍历"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Binary Search Tree Traversal 二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Pre-order-Traversal-前序遍历"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">Pre-order Traversal 前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#In-order-Traversal-中序遍历"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">In-order Traversal 中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Post-order-Traversal-后序遍历"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">Post-order Traversal 后序遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Divide-and-Conquer-分治法"><span class="toc-number">1.3.</span> <span class="toc-text">Divide and Conquer 分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Sort-归并排序"><span class="toc-number">1.3.1.</span> <span class="toc-text">Merge Sort 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quick-Sort-快速排序"><span class="toc-number">1.3.2.</span> <span class="toc-text">Quick Sort 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最近点对-Cloest-Pair-Problem"><span class="toc-number">1.3.3.</span> <span class="toc-text">最近点对 Cloest Pair Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transform-and-Conquer-变治法"><span class="toc-number">1.4.</span> <span class="toc-text">Transform and Conquer 变治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Instance-Simplification-Pre-sorting-预排序"><span class="toc-number">1.4.1.</span> <span class="toc-text">Instance Simplification Pre-sorting 预排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Check-Elements-Uniqueness-判断元素是否独特性"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Check Elements Uniqueness 判断元素是否独特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Find-the-Mode-寻找众数"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Find the Mode 寻找众数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representation-Change"><span class="toc-number">1.4.2.</span> <span class="toc-text">Representation Change</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-堆"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Heap 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Complete-Binary-Tree-完全二叉树"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">Complete Binary Tree 完全二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Heap-Construction-堆的构建"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">Heap Construction 堆的构建</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-Insert-堆的插入"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Heap Insert 堆的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-Delete-堆的删除"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">Heap Delete 堆的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heap-Sort-堆排序"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">Heap Sort 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#步骤"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分析"><span class="toc-number">1.4.2.4.2.</span> <span class="toc-text">分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary-of-sorting-algorithms"><span class="toc-number">1.5.</span> <span class="toc-text">Summary of sorting algorithms</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Yang Li"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Yang's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline" style="color: undefined">Algorithim 概览</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-06-15 00:55:19" itemprop="dateCreated datePublished" datetime="2020-06-15T00:55:19-07:00">2020-06-15</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2020-06-19 00:47:00" itemprop="dateModified" datetime="2020-06-19T00:47:00-07:00">2020-06-19</time></div><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Comments"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-chat-3-line"></use></svg></span> <a href="/2020/06/15/10-common-algo-review/#disqus_thread"></a><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/notes/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">notes</span></a><a class="tag" href="/tags/algorithim/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">algorithim</span></a><a class="tag" href="/tags/bcit/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">bcit</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><blockquote>
<p>总结下暑假算法课中学习到的知识点，代码主要以 python 和 typescript 来展示。</p>
</blockquote>
<h1 id="Sorting-Algorithim-排序算法"><a href="#Sorting-Algorithim-排序算法" class="headerlink" title="Sorting Algorithim 排序算法"></a>Sorting Algorithim 排序算法</h1><h2 id="Brute-Force-暴力求解"><a href="#Brute-Force-暴力求解" class="headerlink" title="Brute Force 暴力求解"></a>Brute Force 暴力求解</h2><blockquote>
<p>从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1 次猜中，但最坏的情况<code>Worst case</code>就是 10 次。</p>
</blockquote>
<p>然而，暴力求解的算法并不是最有效的，在之后的算法<code>Divide and conquer</code>中，我们可以猜 0，然后递增到 5。根据给出的结果再进行猜测会大大提高效率。</p>
<a id="more"></a>

<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><p>暴力求解排序方法主要讲解冒泡排序和选择排序</p>
<h4 id="Bubble-Sort-冒泡排序"><a href="#Bubble-Sort-冒泡排序" class="headerlink" title="Bubble Sort 冒泡排序"></a>Bubble Sort 冒泡排序</h4><blockquote>
<p>假设我们有一个可排序的数组, 冒泡排序即从第一个元素开始，每个元素进行两两比较。如果左边的大于右边的,就进行位置替换。完成第一个 iteration 之后继续从第二个元素开始进行相同的步骤。</p>
</blockquote>
<p>根据定义，我们的伪代码如下:</p>
<pre class=" language-cmd"><code class="language-cmd">for i = 0 to A.length - 1
    for j = 0 to A.length - 1 -i
        if left > right:
            swap(left, right)</code></pre>
<p>比如我们有一个数组<code>[3, 0, 6, 1]</code>。那我们先从第一位<code>3</code>开始， 先是<code>3</code>和<code>0</code>比较，<code>3</code>大于<code>0</code>于是我们进行调换。比较完成后我们递增到下一位继续进行两两比较</p>
<p>现在数组为<code>[0, 3, 6, 1]</code>。于是我们继续进行比较<code>3</code>和<code>6</code>。很明显<code>3</code>小于<code>6</code>，我们不需要进行调换。我们来到最后一组比较<code>6</code>和<code>1</code>。左边大于右边我们进行调换。</p>
<p>此时我们第一个 iteration 的排序完成了, <code>[0, 3, 1, 6]</code>。</p>
<p>同理我们现在从<code>index=1</code>的位置开始进行以上相同的步骤直到结束。</p>
<p>如此我们可以写出冒泡排序的代码</p>
<p><strong>Python</strong></p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">return</span> array</code></pre>
<p><strong>Typescrtipt</strong></p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> bubbleSort <span class="token operator">=</span> list <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> n<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> list<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> list<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">;</span><span class="token punctuation">[</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> list
<span class="token punctuation">}</span></code></pre>
<p>我们可以看出，冒泡排序有两个 for 循环，我们可得出复杂度 Big Oh 为 n 的平方</p>
<h4 id="Selection-Sort-选择排序"><a href="#Selection-Sort-选择排序" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h4><p>选择排序的方法是我们首先设定第一个字符的元素为最小值，然后我们进行数组的循环。如果我们在 iteration 中发现有元素比当前设定的元素小，我们将该元素设置为新的最小值。重复步骤结束 iteration 并把此循环中最小值起始的值替换完成排序。伪代码如下:</p>
<pre class=" language-cmd"><code class="language-cmd">for i = 0 to Array.length -1:
    min = i
    for j = i+1 to Array.length:
        if(j < min):
            min = j
    swap(i, j)</code></pre>
<p>因为暴力求解每个元素进行比较，所以我们用一个简单的数组举例…</p>
<p>假设我们用选择排序算法来排序<code>[3, 0, 2]</code>数组。</p>
<p>首先把最小值<code>min</code>设置为<code>array[0]</code>也就是<code>3</code>, 然后<code>i+1</code>开始进行判断，<code>0</code>小于<code>3</code>。好我们现在把<code>min</code>设置为<code>0</code>然后继续前进。</p>
<p><code>2</code>大于<code>0</code>，我们跳过。于是第一个循环完成了。我们进行<code>i</code>和更新后的最小值<code>min</code>调换得到</p>
<p><code>[0, 3, 2]</code>。</p>
<p>OK, 同理我们从<code>i = 1</code>开始，<code>min</code>现在设置为<code>array[1]</code>也就是<code>3</code>。比较<code>3</code>和<code>2</code>条件成立进行 swap。</p>
<p>最后我们得到<code>[0, 2, 3]</code></p>
<p>选择排序代码如下</p>
<p><strong>Python</strong></p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        min <span class="token operator">=</span> i
        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                min <span class="token operator">=</span> j
        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">return</span> array</code></pre>
<p><strong>Typescript</strong></p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> selectionSort <span class="token operator">=</span> array <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> min <span class="token operator">=</span> i
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        min <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">;</span><span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">}</span></code></pre>
<h3 id="String-Match-字符串匹配"><a href="#String-Match-字符串匹配" class="headerlink" title="String Match 字符串匹配"></a>String Match 字符串匹配</h3><p>回到最开始的搜索内容查询位置问题。用暴力求解的方法也写的话，我们就要每个字符开始进行比较。一旦有一个字符不匹配我们位移一个单位继续进行判断。</p>
<p>比如我们要在<code>I love python</code>中搜索<code>python</code>。首先从<code>I</code>开始进行匹配，直到<code>index = 7</code>的位置才匹配成功并返回<code>index = 7</code>。</p>
<p>伪代码如下:</p>
<pre class=" language-cmd"><code class="language-cmd">for i = 0 to n - m:
    j = 0
    while j < m and pattern[j] = text[i + j] do
        j = j + 1
    if(j = m):
        return i
return -1</code></pre>
<h3 id="Knapsack-Problem-背包问题"><a href="#Knapsack-Problem-背包问题" class="headerlink" title="Knapsack Problem 背包问题"></a>Knapsack Problem 背包问题</h3><p>背包问题即给定一些特定物品并有对应的价格和重量。然后有一个限重 W 的背包，每个物品只能选择一次。在不超重的情况下如何做到价值最大化选择？</p>
<p>举个简单的例子。我们有一个最重承受 10kg 的背包。并有以下物品可以选择: 物品一: 2kg, 10 元。 物品二: 5kg, 30 元。物品三: 4kg, 20 元….如此。</p>
<p>暴力算法来解决这个问题就是将所有可能的组合先全部列出来，然后判断并筛选超重的集合，最后比较所有集合来找到价值最高的集合。</p>
<p>算法效率来讲，假设我们有 n 个物品，那复杂度即为 2 的 n 次方</p>
<h2 id="Decrease-and-Conquer-减治法"><a href="#Decrease-and-Conquer-减治法" class="headerlink" title="Decrease and Conquer 减治法"></a>Decrease and Conquer 减治法</h2><p>这个 section 我们引入减治法。跟暴力求解不同，减治法通过逐步缩小问题规模来解决一个问题。简而言之，回到我们之前猜数字的游戏。如果用暴力求解，我们要一个数字一个数字猜测。减治法可以先把数字对半分，比如猜从 0-10 的数字，我们可以先拆成 0-5 和 6-10。如果我们给出 5 系统显示太高，那我们可以继续对半拆除从 0-4 进行同样的步骤。直到最后我们找到数字也就是一直拆分问题。</p>
<h3 id="Insertation-Sort-插入排序"><a href="#Insertation-Sort-插入排序" class="headerlink" title="Insertation Sort 插入排序"></a>Insertation Sort 插入排序</h3><p>假设我们一个数组<code>[0, 1, 5, 3, 2]</code>。第一部分<code>[0, 1]</code>是有序数列，后半部分为无序数列。也就是说我们每次只要把无序数列的第一个元素插入到正确的位置后，整体问题的规模就减少 1。如果我们重复<code>n-1</code>此后，数组也重新排成有序了。</p>
<blockquote>
<p>重复 n-1 是因为只有一个元素的数组必定是有序的。</p>
</blockquote>
<p>可以把插入排序想象成扑克牌卡片排序。</p>
<p><strong>Python</strong></p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token comment" spellcheck="true"># the index in the left of i</span>
        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>

        <span class="token comment" spellcheck="true"># 如果左边还有数字 并且 当前元素小于它左边的元素：</span>
        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> index <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># 调换当前元素和左边的元素</span>
            array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token comment" spellcheck="true"># 继续向左移动</span>
            j <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token comment" spellcheck="true"># 循环结束 插入到对应的位置</span>
        array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> index
    <span class="token keyword">return</span> array</code></pre>
<p><strong>Typescript</strong></p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> insertionSort <span class="token operator">=</span> array <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> n<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> array<span class="token punctuation">.</span>length
  <span class="token comment" spellcheck="true">//起始为1 因为第一个是有序的</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> index
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">}</span></code></pre>
<p>由上可以看出我们有 2 个循环，所以插入排序的复杂度为 n 的平方</p>
<h3 id="Binary-Search-and-Binary-Tree-二分查找与二叉树"><a href="#Binary-Search-and-Binary-Tree-二分查找与二叉树" class="headerlink" title="Binary Search and Binary Tree 二分查找与二叉树"></a>Binary Search and Binary Tree 二分查找与二叉树</h3><h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><p>目前我们涉及到的算法都是从数组的第一个位置开始然后进行查找。二分查找则从一个数组的中间开始，从左往右一次查找，直到找到该元素或循环结束</p>
<p><strong>Python</strong></p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    l <span class="token operator">=</span> <span class="token number">0</span>
    r <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>
        m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token keyword">if</span> key <span class="token operator">==</span> array<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> m
        <span class="token keyword">elif</span> key <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">:</span>
            r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre>
<p><strong>Typescript</strong></p>
<pre class=" language-ts"><code class="language-ts"><span class="token keyword">const</span> binarySearch <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> l<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">let</span> r<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> array<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> m
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h4><p>将数组(有序)分为两部分，数组的中间元素为树的根节点，左边和右边的元素再进行相同的划分，小于根节点的元素放在左边，大于的再右边。</p>
<h4 id="Binary-Search-Tree-Traversal-二叉树遍历"><a href="#Binary-Search-Tree-Traversal-二叉树遍历" class="headerlink" title="Binary Search Tree Traversal 二叉树遍历"></a>Binary Search Tree Traversal 二叉树遍历</h4><p>根据二叉搜索树我们可以进行数组的插入，查询和删除节点。接下来我们引入二叉树遍历即怎样直到节点是否已经被访问过了。</p>
<h5 id="Pre-order-Traversal-前序遍历"><a href="#Pre-order-Traversal-前序遍历" class="headerlink" title="Pre-order Traversal 前序遍历"></a>Pre-order Traversal 前序遍历</h5><h5 id="In-order-Traversal-中序遍历"><a href="#In-order-Traversal-中序遍历" class="headerlink" title="In-order Traversal 中序遍历"></a>In-order Traversal 中序遍历</h5><h5 id="Post-order-Traversal-后序遍历"><a href="#Post-order-Traversal-后序遍历" class="headerlink" title="Post-order Traversal 后序遍历"></a>Post-order Traversal 后序遍历</h5><h2 id="Divide-and-Conquer-分治法"><a href="#Divide-and-Conquer-分治法" class="headerlink" title="Divide and Conquer 分治法"></a>Divide and Conquer 分治法</h2><blockquote>
<p>分治法的理论为把一个大的问题分成若干个小问题，然后逐个解决小问题，最后将小问题的解决方案合并到原来大问题的解。比如乐高玩具，一个乐高模型分成若干个小问题即乐高零件。小问题的解就是将各个组件先拼好，比如房顶，门之类。最后解决完整的模型。</p>
</blockquote>
<p>在介绍归并排序之前，我们先来了解以下有序数组的合并。我们可以把将两个有序数组的合并看作为解决一个小问题。最终合并所有数组即能解决原本的问题。</p>
<p>我们有两个有序数组<br>a： <code>[2, 3, 8, 9]</code><br>b: <code>[1, 4, 5, 7]</code></p>
<p>假设我们现在需要把 a 和 b 合并为一个新的有序数组到一个空的 c <code>[]</code></p>
<ul>
<li>首先我们用三个变量分别来记录三个数组的索引值并初始化为 0， 数组 1 为<code>i</code>， 数组 2 为<code>j</code>，数组 3 为<code>k</code></li>
<li>然后我们比较 a[i]和 b[i]并将较小的元素存入到数组<code>c[0]中</code>。初始化为 0，所以我们比较<code>a[0]</code>和<code>b[0]</code>。</li>
<li>之后我们将较小元素的数组索引值和数组 c 的索引值加 1<ul>
<li>然后我们继续重复第二步进行比较</li>
</ul>
</li>
</ul>
<p>最好的情况下我们要比较 n/2 个元素，最坏的情况要比较 n - 1 次。由此可以得到合并有序数组的复杂度为 n</p>
<h3 id="Merge-Sort-归并排序"><a href="#Merge-Sort-归并排序" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h3><p>考完试再更新吧 先了解以下</p>
<p>复杂度 nlogn</p>
<h3 id="Quick-Sort-快速排序"><a href="#Quick-Sort-快速排序" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h3><blockquote>
<p>Lumuto 划分：首选选一个中间值来作为我们的中轴(pivot), 所有比中轴值小的元素位于中轴的左侧，而大于中轴值的元素位于中轴的右侧。</p>
</blockquote>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    l <span class="token operator">=</span> <span class="token number">0</span>
    r <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    pivot <span class="token operator">=</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span>
    s <span class="token operator">=</span> l
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> p<span class="token punctuation">:</span>
            s <span class="token operator">+=</span> <span class="token number">1</span>
            a<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>s<span class="token punctuation">]</span>
            a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span>
    <span class="token keyword">return</span> s</code></pre>
<h3 id="最近点对-Cloest-Pair-Problem"><a href="#最近点对-Cloest-Pair-Problem" class="headerlink" title="最近点对 Cloest Pair Problem"></a>最近点对 Cloest Pair Problem</h3><h2 id="Transform-and-Conquer-变治法"><a href="#Transform-and-Conquer-变治法" class="headerlink" title="Transform and Conquer 变治法"></a>Transform and Conquer 变治法</h2><h3 id="Instance-Simplification-Pre-sorting-预排序"><a href="#Instance-Simplification-Pre-sorting-预排序" class="headerlink" title="Instance Simplification Pre-sorting 预排序"></a>Instance Simplification Pre-sorting 预排序</h3><h4 id="Check-Elements-Uniqueness-判断元素是否独特性"><a href="#Check-Elements-Uniqueness-判断元素是否独特性" class="headerlink" title="Check Elements Uniqueness 判断元素是否独特性"></a>Check Elements Uniqueness 判断元素是否独特性</h4><p>给出一个数组，判断是否该数组存在重复元素。</p>
<p>我们先用暴力求解来看下</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_unique_bf</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 存储当前索引元素变量</span>
        index_value <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token comment" spellcheck="true"># 循环数组 查找是否有匹配相等的</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> index_value<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre>
<p>由上可以可以得出复杂度为 n 的平方。</p>
<p>假设我们先将数组进行排序得到一个有序数组，然后在进行判断是否存在重复元素。因为一个有序数组，我们只要查看一个元素是否跟它的下一个元素是否相等即可。比如<code>[2, 3, 3, 5]</code>。</p>
<p>用代码来实现</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_unique_presort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 假设我们先进行排序</span>
    array<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> array<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre>
<p>由于算法由两部分构成（排序和主循环），所以该其复杂度也应该为两部分：排序的复杂度加检查的复杂度。即为 nlogn + n。得到复杂度 nlogn</p>
<h4 id="Find-the-Mode-寻找众数"><a href="#Find-the-Mode-寻找众数" class="headerlink" title="Find the Mode 寻找众数"></a>Find the Mode 寻找众数</h4><p>众数是出现在一组数据中最频繁的数。这个算法在项目中应该算很常见，比如我最近在做的项目要涉及到计算出最常用的三个标签，或者使用频率最高的技能。</p>
<p>我们先来看下用暴力求解如何实现这个算法</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_mode</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
  n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true"># 统计每个数字的频率</span>
  counter <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    counter<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> counter<span class="token punctuation">.</span>get<span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>

  occurence <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> counter<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> value <span class="token operator">></span> occurence<span class="token punctuation">:</span>
      occurence <span class="token operator">=</span> value
      mode <span class="token operator">=</span> key
  <span class="token keyword">return</span> mode
</code></pre>
<p>最坏的情况下我们的数组每个元素都只出现一次 <code>[1, 2, 3, 4, 5, 6]</code>。复杂度为 n2</p>
<p>如果我们先将数组进行排序，那么相同的元素在有序数组里一定是相邻的。</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_mode_presort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
    array<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># sort array</span>
    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> freq <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>
        temp_freq <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> temp_mode <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">while</span> i <span class="token operator">+</span> temp_freq <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">and</span> array<span class="token punctuation">[</span>i<span class="token operator">+</span>temp_freq<span class="token punctuation">]</span> <span class="token operator">==</span> temp_mode<span class="token punctuation">:</span>
            temp_freq <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> temp_freq <span class="token operator">></span> freq<span class="token punctuation">:</span>
            freq <span class="token operator">=</span> temp_freq<span class="token punctuation">;</span> mode <span class="token operator">=</span> temp_mode
        i <span class="token operator">+=</span> temp_freq
    <span class="token keyword">return</span> mode

array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The mode of the array is %d."</span> <span class="token operator">%</span> compute_mode_presort<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>算法复杂度可以得出：O(nlog n) + O(log n) = O(nlog n)</p>
<h3 id="Representation-Change"><a href="#Representation-Change" class="headerlink" title="Representation Change"></a>Representation Change</h3><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h4><h5 id="Complete-Binary-Tree-完全二叉树"><a href="#Complete-Binary-Tree-完全二叉树" class="headerlink" title="Complete Binary Tree 完全二叉树"></a>Complete Binary Tree 完全二叉树</h5><p>堆一个完全二叉树，即除了最后一层的节点没有铺满外，其他层均已排满。</p>
<h5 id="Heap-Construction-堆的构建"><a href="#Heap-Construction-堆的构建" class="headerlink" title="Heap Construction 堆的构建"></a>Heap Construction 堆的构建</h5><p>我们把堆分为两种，一种是大顶堆(max heap)即数字越大的优先级越高，另一种为小顶堆(min heap)即数字越小的优先级越高。</p>
<p>我们以 max heap 为例，由于数字越大的优先级更高， 于是数字越大即优先级越高的数字就越靠近根节点的位置。</p>
<p>并且父节点的值总是大于或等于其子节点的值。</p>
<p>如何构建一个堆排序呢？</p>
<ul>
<li>首先我们将数组的元素以 binary tree 的形式表现出来。(无序不满足堆的性质)</li>
<li>然后从堆尾由上至下进行节点元素的调换。直到所有节点都满足堆的性质（即父节点的值总是大于或等于其子节点的值)</li>
</ul>
<blockquote>
<p>注: 父节点没有子节点时，左右的排序不需要满足右节点大于左节点（不同于二叉树搜索）</p>
</blockquote>
<p>//需要图片来描述步骤</p>
<h4 id="Heap-Insert-堆的插入"><a href="#Heap-Insert-堆的插入" class="headerlink" title="Heap Insert 堆的插入"></a>Heap Insert 堆的插入</h4><p>假设我们要把一个数值插入到一个堆中,如何来实现呢?</p>
<p>给定一个堆的排序 <code>[16, 15, 10, 14, 7, 9, 3, 2, 8 ,1]</code>，我们想要插入<code>17</code>到这个堆中</p>
<ul>
<li>首先我们把 17 放到数组的最后一个位置中</li>
<li>我们将 17 与它的父节点进行比较，也就是 7。7 小于 17 不满足堆的性质，于是我们进行调换 7 和 17 的位置</li>
<li>继续进行与父节点对比，17 和 15， 依旧不满足父节点大于子节点的的性质，我们调换 17 和 15 的位置</li>
<li>现在对比 17 和 16， 依然，我们进行调换。</li>
<li>重复以上步骤直到满足堆的性质</li>
</ul>
<blockquote>
<p>我们可以发现给定一个有 N 个元素的数组，堆的高度为 log2 为底 n 的对数。比如之前的例子，我们有 10 个元素，那堆的高度为 log2 10 = 3(向下取整)。根据堆得性质，我们发现插入一个元素到堆中需要进行堆的高度次元素。由此可得堆得算法复杂度为 log2 为底 n 的对数</p>
</blockquote>
<h4 id="Heap-Delete-堆的删除"><a href="#Heap-Delete-堆的删除" class="headerlink" title="Heap Delete 堆的删除"></a>Heap Delete 堆的删除</h4><p>从堆中删除一个元素的实现方法为：</p>
<ul>
<li>交换根节点的元素与堆尾的位置(数组中头尾交换)</li>
<li>删除堆尾</li>
<li>从上到下调整堆的结构（与堆的插入：由下至上相反）<ul>
<li>如果不满足堆的性质就交换两个节点的值</li>
</ul>
</li>
</ul>
<p>比如我们之前的例子，<code>[17, 16, 10, 14, 15, 9, 3, 2, 8, 1, 7]</code>。</p>
<p>我们想要删除节点 17。按照上面的步骤来实现即</p>
<ul>
<li>替换 17 与 7 的位置</li>
<li>删除 17</li>
<li>7 与 16 对比，不满足堆的性质调换位置</li>
<li>7 小于 15， 调换</li>
</ul>
<h4 id="Heap-Sort-堆排序"><a href="#Heap-Sort-堆排序" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>构建堆</li>
<li>堆顶和堆尾的值交换顺序，并删除交换后的堆尾元素</li>
<li>调整堆的结构（利用堆的删除方法，由上至下）</li>
<li>重复第二和第三步 直到堆为空</li>
</ul>
<p><a href="http://btv.melezinek.cz" target="_blank" rel="noopener">http://btv.melezinek.cz</a></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><h2 id="Summary-of-sorting-algorithms"><a href="#Summary-of-sorting-algorithms" class="headerlink" title="Summary of sorting algorithms"></a>Summary of sorting algorithms</h2><table>
<thead>
<tr>
<th>算法</th>
<th>最好的情况</th>
<th>最坏的情况</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>n2</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>n</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>n</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>n logn</td>
<td>n logn</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>n logn</td>
<td>n2</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>n logn</td>
<td>n logn</td>
<td>不稳定</td>
</tr>
</tbody></table>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" target="_blank" rel="noopener"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="Wechat" title="Wechat"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" target="_blank" rel="noopener"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="Paypal" title="Paypal"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" target="_blank" rel="noopener"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="Buy me a coffee" title="Buy me a coffee"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="https://paypal.com" target="_blank" rel="noopener"><img loading="lazy" src="https://www.paypalobjects.com/images/shared/paypal-logo-129x32.svg" alt="paypal" title="paypal"></a><div><span style="color:#2D70B5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-paypal-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Yang Li</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/" title="Algorithim 概览">https://yangblog.netlify.app/2020/06/15/10-common-algo-review/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless stating additionally.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/06/17/11-es6-notes/" rel="prev" title="ES6与Javascrpit的对比"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">ES6与Javascrpit的对比</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/06/15/09-customize-powershell/" rel="next" title="自定义Windows10下的terminal外观"><span class="post-nav-text">自定义Windows10下的terminal外观</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Yang Li</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v4.2.1</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.7.2</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-05-23T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script>let date = new Date();
let today = (date.getMonth() + 1) + "-" + date.getDate()
if ("4-4,9-18".indexOf(today) !== -1) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>