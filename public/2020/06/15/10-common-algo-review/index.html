<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法导论概览 | Yang's Blog</title><meta name="description" content="总结暑假算法课 COMP3761 中学习到的知识点，代码实现以 python 来展示。课程内容参考 Introduction to The Design and Analysis of Algorithm. 前半部分主要分析各种排序算法的原理以及代码实现。后半部分主要为图算法和最短路径的应用。   Brute Force 暴力求解 Decrease and Conquer 减治法 Divide"><meta name="keywords" content="notes,algorithim"><meta name="author" content="Yang Li"><meta name="copyright" content="Yang Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/yang-favicon.png"><link rel="canonical" href="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="算法导论概览"><meta property="og:url" content="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/"><meta property="og:site_name" content="Yang's Blog"><meta property="og:description" content="总结暑假算法课 COMP3761 中学习到的知识点，代码实现以 python 来展示。课程内容参考 Introduction to The Design and Analysis of Algorithm. 前半部分主要分析各种排序算法的原理以及代码实现。后半部分主要为图算法和最短路径的应用。   Brute Force 暴力求解 Decrease and Conquer 减治法 Divide"><meta property="og:image" content="https://3.bp.blogspot.com/-bsAe5iHfUvw/XMm2l8YCMtI/AAAAAAAAA28/9-Uj-v3GHhIE06c1_HdSEOeXML1byHInACLcBGAs/s1600/what-is-an-algorithm.png"><meta property="article:published_time" content="2020-06-15T07:55:19.000Z"><meta property="article:modified_time" content="2020-07-21T21:02:37.480Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="ES6与Javascrpit的对比" href="https://yangblog.netlify.app/2020/06/17/11-es6-notes/"><link rel="next" title="自定义Windows10下的terminal外观" href="https://yangblog.netlify.app/2020/06/15/09-customize-powershell/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Yang Li","link":"链接: ","source":"来源: Yang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/yang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">62</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Brute-Force-暴力求解"><span class="toc-number">1.</span> <span class="toc-text">Brute Force 暴力求解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Bubble-Sort-冒泡排序"><span class="toc-number">1.1.</span> <span class="toc-text">1. Bubble Sort 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例"><span class="toc-number">1.1.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-number">1.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析"><span class="toc-number">1.1.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Selection-Sort-选择排序"><span class="toc-number">1.2.</span> <span class="toc-text">2. Selection Sort 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Brtute-Force-String-Match-暴力求解-字符串匹配"><span class="toc-number">1.3.</span> <span class="toc-text">3. Brtute Force String Match 暴力求解 字符串匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Knapsack-Problem-背包问题"><span class="toc-number">1.4.</span> <span class="toc-text">4. Knapsack Problem 背包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Decrease-and-Conquer-减治法"><span class="toc-number">2.</span> <span class="toc-text">Decrease and Conquer 减治法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Insertation-Sort-插入排序"><span class="toc-number">2.1.</span> <span class="toc-text">1. Insertation Sort 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-3"><span class="toc-number">2.1.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-3"><span class="toc-number">2.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析-3"><span class="toc-number">2.1.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Binary-Search-二分查找"><span class="toc-number">2.2.</span> <span class="toc-text">2. Binary Search 二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Binary-Search-Tree-Traversal-二叉树的遍历"><span class="toc-number">2.3.</span> <span class="toc-text">3. Binary Search Tree Traversal 二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-order-Traversal-前序遍历"><span class="toc-number">2.3.1.</span> <span class="toc-text">Pre-order Traversal 前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-order-Traversal-中序遍历"><span class="toc-number">2.3.2.</span> <span class="toc-text">In-order Traversal 中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-order-Traversal-后序遍历"><span class="toc-number">2.3.3.</span> <span class="toc-text">Post-order Traversal 后序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Divide-and-Conquer-分治法"><span class="toc-number">3.</span> <span class="toc-text">Divide and Conquer 分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-有序数组合并"><span class="toc-number">3.1.</span> <span class="toc-text">1. 有序数组合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Merge-Sort-归并排序"><span class="toc-number">3.2.</span> <span class="toc-text">2. Merge Sort 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-4"><span class="toc-number">3.2.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析-4"><span class="toc-number">3.2.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">3.2.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Quick-Sort-快速排序"><span class="toc-number">3.3.</span> <span class="toc-text">3. Quick Sort 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-5"><span class="toc-number">3.3.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-4"><span class="toc-number">3.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析-5"><span class="toc-number">3.3.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考-1"><span class="toc-number">3.3.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Transform-and-Conquer-变治法"><span class="toc-number">4.</span> <span class="toc-text">Transform and Conquer 变治法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Instance-Simplification-Pre-sorting-预排序"><span class="toc-number">4.1.</span> <span class="toc-text">1. Instance Simplification Pre-sorting 预排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check-Elements-Uniqueness-判断数组内元素是否重复"><span class="toc-number">4.1.1.</span> <span class="toc-text">Check Elements Uniqueness 判断数组内元素是否重复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-5"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-6"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-the-Mode-寻找众数"><span class="toc-number">4.1.2.</span> <span class="toc-text">Find the Mode 寻找众数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-6"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-7"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Representation-Change-改变数据的表现形式"><span class="toc-number">4.2.</span> <span class="toc-text">2. Representation Change 改变数据的表现形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-堆的定义"><span class="toc-number">4.2.1.</span> <span class="toc-text">Heap 堆的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Implementation-堆的应用"><span class="toc-number">4.2.2.</span> <span class="toc-text">Heap Implementation 堆的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Insert-堆的插入"><span class="toc-number">4.2.3.</span> <span class="toc-text">Heap Insert 堆的插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-8"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Delete-堆的删除"><span class="toc-number">4.2.4.</span> <span class="toc-text">Heap Delete 堆的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-9"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Sort-堆排序"><span class="toc-number">4.2.5.</span> <span class="toc-text">Heap Sort 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#步骤"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考-2"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Space-and-Time-Trade-Offs-时空权衡"><span class="toc-number">5.</span> <span class="toc-text">Space and Time Trade-Offs 时空权衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Counting-Sort-计数排序"><span class="toc-number">5.1.</span> <span class="toc-text">1. Counting Sort 计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-6"><span class="toc-number">5.1.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析-10"><span class="toc-number">5.1.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考-3"><span class="toc-number">5.1.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Horspool’s-Algorithm-String-Matching-字符串匹配算法"><span class="toc-number">5.2.</span> <span class="toc-text">2. Horspool’s Algorithm: String Matching 字符串匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-7"><span class="toc-number">5.2.1.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Hash-哈希"><span class="toc-number">5.3.</span> <span class="toc-text">3. Hash 哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hasing-Function-哈希函数"><span class="toc-number">5.3.1.</span> <span class="toc-text">Hasing Function 哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collision-Handling-冲突解决"><span class="toc-number">5.3.2.</span> <span class="toc-text">Collision Handling 冲突解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Separate-Chaining-分离链接"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">1. Separate Chaining 分离链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Closed-Hashing-封闭散列"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">2. Closed Hashing 封闭散列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Summary-of-sorting-algorithms-排序算法总结"><span class="toc-number">5.4.</span> <span class="toc-text">4. Summary of sorting algorithms 排序算法总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-Structure-数据结构"><span class="toc-number">6.</span> <span class="toc-text">Data Structure 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linear-Data-Structure-线性数据结构"><span class="toc-number">6.1.</span> <span class="toc-text">1. Linear Data Structure 线性数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-数组"><span class="toc-number">6.1.1.</span> <span class="toc-text">Array 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linked-List-链表"><span class="toc-number">6.1.2.</span> <span class="toc-text">Linked List 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-11"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-栈"><span class="toc-number">6.1.3.</span> <span class="toc-text">Stack 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-12"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-队列"><span class="toc-number">6.1.4.</span> <span class="toc-text">Queue 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-13"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Non-Linear-Data-Structures-Graph-图"><span class="toc-number">6.2.</span> <span class="toc-text">2. Non-Linear Data Structures: Graph 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Types-图的分类"><span class="toc-number">6.2.1.</span> <span class="toc-text">Types 图的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representing-Graphs-图的表达方式"><span class="toc-number">6.2.2.</span> <span class="toc-text">Representing Graphs 图的表达方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Adjacency-Matrix-邻接矩阵"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">1. Adjacency Matrix 邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Adjacency-Lists-邻接表"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">2. Adjacency Lists 邻接表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-Traversal-图的遍历"><span class="toc-number">6.2.3.</span> <span class="toc-text">Graph Traversal 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Depth-First-Search-DFS-深度优先搜索"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">1. Depth-First Search (DFS) 深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Breadth-First-Search-BFS-广度优先搜素"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">2. Breadth-First Search (BFS) 广度优先搜素</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Greedy-Approach-贪心算法"><span class="toc-number">7.</span> <span class="toc-text">Greedy Approach 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Prim’s-Algorithm-普林姆算法"><span class="toc-number">7.1.</span> <span class="toc-text">1. Prim’s Algorithm 普林姆算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例-8"><span class="toc-number">7.1.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考-4"><span class="toc-number">7.1.2.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Kruskal’s-Algorithm-克鲁斯卡尔算法"><span class="toc-number">7.2.</span> <span class="toc-text">2. Kruskal’s Algorithm 克鲁斯卡尔算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Dijkstra’s-Algorithm-迪克斯特拉算法"><span class="toc-number">7.3.</span> <span class="toc-text">3. Dijkstra’s Algorithm: 迪克斯特拉算法</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://3.bp.blogspot.com/-bsAe5iHfUvw/XMm2l8YCMtI/AAAAAAAAA28/9-Uj-v3GHhIE06c1_HdSEOeXML1byHInACLcBGAs/s1600/what-is-an-algorithm.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Yang's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">算法导论概览</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-15 00:55:19"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-21 14:02:37"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>总结暑假算法课 COMP3761 中学习到的知识点，代码实现以 python 来展示。课程内容参考 <a href="https://www.amazon.ca/Introduction-Design-Analysis-Algorithms-3rd/dp/0132316811" target="_blank" rel="noopener">Introduction to The Design and Analysis of Algorithm</a>. 前半部分主要分析各种排序算法的原理以及代码实现。后半部分主要为图算法和最短路径的应用。</p>
</blockquote>
<ol>
<li>Brute Force 暴力求解</li>
<li>Decrease and Conquer 减治法</li>
<li>Divide and Conquer 分治法</li>
<li>Transform and Conquer 变治法</li>
<li>Time Space Tradeoff 时空权衡</li>
<li>Data Structure 数据结构</li>
<li>Greedy Approach 贪心算法</li>
</ol>
<h1 id="Brute-Force-暴力求解"><a href="#Brute-Force-暴力求解" class="headerlink" title="Brute Force 暴力求解"></a>Brute Force 暴力求解</h1><blockquote>
<p>从字面意思理解，brute force 就是用最直接的方法来解决相应的问题。比如我们设计一个猜数字的游戏。数字范围为 0-10，根据用户的输入返回是否大还是小。那暴力求解的算法就是从 0 开始然后递增，最好的情况是 1 次猜中，但最坏的情况<code>Worst case</code>就是 10 次。</p>
</blockquote>
<h2 id="1-Bubble-Sort-冒泡排序"><a href="#1-Bubble-Sort-冒泡排序" class="headerlink" title="1. Bubble Sort 冒泡排序"></a>1. Bubble Sort 冒泡排序</h2><p>假设我们有一个可排序的数组, 冒泡排序即从第一个元素开始，每个元素进行两两比较。如果左边的大于右边的,就进行位置替换。完成第一个 iteration 之后继续从第二个元素开始进行相同的步骤。</p>
<p>冒泡排序伪代码如下:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> <span class="built_in">to</span> A.<span class="built_in">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> <span class="built_in">to</span> A.<span class="built_in">length</span> - <span class="number">1</span> -i</span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="literal">right</span>:</span><br><span class="line">            swap(left, <span class="literal">right</span>)</span><br></pre></td></tr></table></figure>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>比如我们有一个数组<code>[3, 0, 6, 1]</code>。那我们先从第一位<code>3</code>开始， 先是<code>3</code>和<code>0</code>比较，<code>3</code>大于<code>0</code>于是我们进行调换。比较完成后我们递增到下一位继续进行两两比较</p>
<p>现在数组为<code>[0, 3, 6, 1]</code>。于是我们继续进行比较<code>3</code>和<code>6</code>。很明显<code>3</code>小于<code>6</code>，我们不需要进行调换。我们来到最后一组比较<code>6</code>和<code>1</code>。左边大于右边我们进行调换。</p>
<p>此时我们第一个 iteration 的排序完成了, <code>[0, 3, 1, 6]</code>。</p>
<p>同理我们现在从<code>index=1</code>的位置开始进行以上相同的步骤直到结束。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span> -i):</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>]):</span><br><span class="line">                array[j], array[j+<span class="number">1</span>] = array[j+<span class="number">1</span>], array[j]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>冒泡排序有两个<code>for</code>循环，所以冒泡排序的复杂度 n<sup>2</sup></p>
<h2 id="2-Selection-Sort-选择排序"><a href="#2-Selection-Sort-选择排序" class="headerlink" title="2. Selection Sort 选择排序"></a>2. Selection Sort 选择排序</h2><p>选择排序首先设定数组第一个字符的元素为最小值，然后遍历整个数组。如果在遍历过程中发现有元素小于当前设定的最小值，就将该元素设置为新的最小值。</p>
<p>重复步骤结束 iteration 并把此循环中最小值起始的值替换完成排序。伪代码实现如下:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">0</span> to Array.<span class="built_in">length</span> <span class="number">-1</span>:</span><br><span class="line">    <span class="built_in">min</span> = <span class="built_in">i</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span> to Array.<span class="built_in">length</span>:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">j</span> &lt; <span class="built_in">min</span>):</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">j</span></span><br><span class="line">    swap(<span class="built_in">i</span>, <span class="built_in">j</span>)</span><br></pre></td></tr></table></figure>

<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>假设我们用选择排序算法来排序<code>[3, 0, 2]</code>数组。</p>
<p>首先把最小值<code>min</code>设置为<code>array[0]</code>也就是<code>3</code>, 然后<code>i+1</code>开始进行判断，<code>0</code>小于<code>3</code>。于是我们现在把<code>min</code>设置为<code>0</code>。</p>
<p>现在<code>2</code>大于<code>0</code>，不需要更改最小值。于是第一个循环完成了。将<code>i</code>和更新后的最小值<code>min</code>调换，即调换<code>3</code>和<code>0</code>的位置得到</p>
<p><code>[0, 3, 2]</code>。</p>
<p>同理我们从<code>i = 1</code>开始第二个 iteration，<code>min</code>现在设置为<code>array[1]</code>也就是<code>3</code>。比较<code>3</code>和<code>2</code>条件成立进行调换位置。</p>
<p>最后我们得到<code>[0, 2, 3]</code></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[min]):</span><br><span class="line">                min = j</span><br><span class="line">        array[i], array[min] = array[min], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>选择排序的复杂度 n<sup>2</sup></p>
<h2 id="3-Brtute-Force-String-Match-暴力求解-字符串匹配"><a href="#3-Brtute-Force-String-Match-暴力求解-字符串匹配" class="headerlink" title="3. Brtute Force String Match 暴力求解 字符串匹配"></a>3. Brtute Force String Match 暴力求解 字符串匹配</h2><p>在浏览器查找一个字符串时，我们可以用<code>Ctrl+F</code>来进行文本内容的匹配搜索。如果暴力求解的方法来实现字符串匹配，我们就要对字符串内每个字符开始进行比较。一旦有一个字符不匹配我们位移一个单位继续进行判断。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>比如我们要在<code>I love python</code>中搜索<code>python</code>。首先从<code>I</code>开始，<code>p</code>并不匹配<code>I</code>，移动索引一个单位。</p>
<p>现在<code>python</code>与<code>love py</code>对齐进行匹配。</p>
<p><code>p</code>依旧不匹配空格。同理移动一个索引继续匹配，直到 index = 7 的位置才匹配成功并返回 index = 7。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n - m:</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> pattern[j] = text[i + j]:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(j = m):</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最坏的情况下我们要进行<code>(n-m+1)m</code>次对比。</p>
<h2 id="4-Knapsack-Problem-背包问题"><a href="#4-Knapsack-Problem-背包问题" class="headerlink" title="4. Knapsack Problem 背包问题"></a>4. Knapsack Problem 背包问题</h2><p>背包问题即给定一些特定物品并有对应的价格和重量。然后有一个限重 W 的背包，每个物品只能选择一次。在不超重的情况下如何做到<strong>价值最大化</strong>选择？</p>
<p>比如我们有一个最重承受 10kg 的背包。并有以下物品可以选择: 物品一: 2kg, 10 元。 物品二: 5kg, 30 元。物品三: 4kg, 20 元….如此。</p>
<p>用暴力算法来解决这个问题即将所有可能的组合先全部列出来，然后判断并筛选超重的集合，最后比较所有集合来找到价值最高的集合。</p>
<p>算法效率来讲，假设我们有 n 个物品，那复杂度即为 <strong>2<sup>n</sup></strong></p>
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h1 id="Decrease-and-Conquer-减治法"><a href="#Decrease-and-Conquer-减治法" class="headerlink" title="Decrease and Conquer 减治法"></a>Decrease and Conquer 减治法</h1><blockquote>
<p>跟暴力求解不同，减治法是通过<strong>逐步缩小问题规模</strong>来解决一个问题。简而言之，回到我们之前猜数字的游戏。如果用暴力求解，我们要一个数字一个数字猜测。减治法可以先把数字对半分，比如猜从 0-10 的数字，我们可以先拆成 0-5 和 6-10。如果我们给出 5 系统显示太高，那我们可以继续对半拆除从 0-4 进行同样的步骤。直到最后我们找到数字也就是一直拆分问题。</p>
</blockquote>
<h2 id="1-Insertation-Sort-插入排序"><a href="#1-Insertation-Sort-插入排序" class="headerlink" title="1. Insertation Sort 插入排序"></a>1. Insertation Sort 插入排序</h2><p>插入排序从数组的第一个索引开始，跟左边的元素进行比较，如果小于左边的元素进行调换。</p>
<p>假设给定一个数组<code>[0, 1, 5, 3, 2]</code>。</p>
<p>第一部分<code>[0, 1]</code>是有序数列，后半部分为无序数列。如果我们每次把无序数列的第一个元素插入到正确的位置后，整体问题的规模就减少 1。</p>
<p>如次重复<code>n-1</code>次后，数组也重新排成有序了。</p>
<blockquote>
<p>重复 n-1 是因为只有一个元素的数组必定是有序的。</p>
</blockquote>
<p>可以把插入排序想象成扑克牌卡片排序。</p>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p>假设我们对数组<code>A=[3, 2, 4, 0]</code>进行插入排序</p>
<p>首先从 A[0]开始，第一个元素左边没有其他元素，所以<code>3</code>在正确的位置。现在我们无序部分为<code>[2, 4 ,0]</code></p>
<p>我们发现 2 &lt; 3, 于是我们调换 2 和 3 的位置得到<code>[2, 3, 4, 0]</code>。现在无序部分为<code>[4, 0]</code>。</p>
<p>4 不需要任何位置更改，于是无序部分只剩下<code>[0]</code>。</p>
<p>我们把 0 跟左边的对比，直到 0 &lt; 2 完成左移的过程。所以我们把 0 插入到第一个 index。最终得到有序数组<code>[0, 2, 3, 4]</code></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        index = array[i]</span><br><span class="line">        <span class="comment"># the index in the left of i</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果左边还有数字 并且 当前元素小于它左边的元素：</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; array[j]:</span><br><span class="line">            <span class="comment"># 调换当前元素和左边的元素</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]</span><br><span class="line">            <span class="comment"># 继续向左移动</span></span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束 插入到对应的位置</span></span><br><span class="line">        array[j + <span class="number">1</span>] = index</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><code>插入排序</code>的复杂度为 n<sup>2</sup></p>
<h2 id="2-Binary-Search-二分查找"><a href="#2-Binary-Search-二分查找" class="headerlink" title="2. Binary Search 二分查找"></a>2. Binary Search 二分查找</h2><p>目前我们涉及到的算法都是从数组的第一个位置开始然后进行遍历判断。二分查找则从一个数组的中间开始，从左往右一次查找，直到找到该元素或循环结束。</p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(array, key)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(array) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == array[m]:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">elif</span> key &lt; array[m]:</span><br><span class="line">            r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Binary-Search-Tree-Traversal-二叉树的遍历"><a href="#3-Binary-Search-Tree-Traversal-二叉树的遍历" class="headerlink" title="3. Binary Search Tree Traversal 二叉树的遍历"></a>3. Binary Search Tree Traversal 二叉树的遍历</h2><p>将数组(有序)分为两部分，数组的中间元素为树的根节点，左边和右边的元素再进行相同的划分，小于根节点的元素放在左边，大于的在右边。</p>
<p>根据二叉搜索树我们可以进行数组的插入，查询和删除节点。接下来我们引入二叉树遍历即怎样知道节点是否已经被访问过了。</p>
<h3 id="Pre-order-Traversal-前序遍历"><a href="#Pre-order-Traversal-前序遍历" class="headerlink" title="Pre-order Traversal 前序遍历"></a>Pre-order Traversal 前序遍历</h3><p>从 Root 开始，每个节点进行<code>Visit -&gt; Left -&gt; Right</code></p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/1WxLM2hwL-U" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h3 id="In-order-Traversal-中序遍历"><a href="#In-order-Traversal-中序遍历" class="headerlink" title="In-order Traversal 中序遍历"></a>In-order Traversal 中序遍历</h3><p>从 Root 开始，每个节点进行<code>Left -&gt; Visit -&gt; Right</code></p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/5dySuyZf9Qg" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h3 id="Post-order-Traversal-后序遍历"><a href="#Post-order-Traversal-后序遍历" class="headerlink" title="Post-order Traversal 后序遍历"></a>Post-order Traversal 后序遍历</h3><p>从 Root 开始，每个节点进行<code>Left -&gt; Right -&gt; Visit</code></p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/4zVdfkpcT6U" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h1 id="Divide-and-Conquer-分治法"><a href="#Divide-and-Conquer-分治法" class="headerlink" title="Divide and Conquer 分治法"></a>Divide and Conquer 分治法</h1><blockquote>
<p>分治法的理论为把一个大的问题分成若干个小问题，然后逐个解决小问题，最后将小问题的解决方案合并到原来大问题的解。比如乐高玩具，一个乐高模型分成若干个小问题即乐高零件。小问题的解就是将各个组件先拼好，比如房顶，门之类。最后再将各个小组件组合起来拼成完整的模型。</p>
</blockquote>
<h2 id="1-有序数组合并"><a href="#1-有序数组合并" class="headerlink" title="1. 有序数组合并"></a>1. 有序数组合并</h2><p>在介绍归并排序和快速排序之前，我们先来了解以下有序数组的合并。</p>
<p>给定两个有序数组<code>a</code>和<code>b</code></p>
<p><code>a = [2, 3, 8, 9]</code><br><code>b = [1, 4, 5, 7]</code></p>
<p>现在需要把数组 a 和 b 合并为一个新的有序数组到一个空的数组 <code>c []</code>。</p>
<ol>
<li>首先我们用三个变量分别来记录三个数组的索引值并初始化为 0， 数组 a 为<code>i</code>， 数组 b 为<code>j</code>，数组 c 为<code>k</code>。</li>
<li>然后我们比较 <code>a[i]</code> 和 <code>b[j]</code> 并将较小的元素存入到数组<code>c[0]中</code>。初始化为 0，所以我们首先比较<code>a[0]</code>和<code>b[0]</code>。</li>
<li>之后我们将较小元素的数组索引和数组 c 的索引加 1。</li>
<li>然后我们继续重复第二步进行比较</li>
</ol>
<p>最好的情况下我们要比较 <code>n/2</code> 个元素，最坏的情况要比较 <code>n-1</code> 次。</p>
<p>由此可以得到合并有序数组的复杂度为 <code>n</code>。</p>
<h2 id="2-Merge-Sort-归并排序"><a href="#2-Merge-Sort-归并排序" class="headerlink" title="2. Merge Sort 归并排序"></a>2. Merge Sort 归并排序</h2><p>归并排序首先要将数组一直拆分直到数组内只有一个元素剩余。然后对拆分后的数组进行重新排序，排序完成后进行归并即得到有序的数组。</p>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>给定一个数组<code>[2, 1, 8, 6]</code>。</p>
<p>首先拆分成<code>[2, 1]</code>和<code>[8, 6]</code>。然后继续进行拆分直到数组内只有一个元素，因为<strong>只有一个元素的数组必定是有序的</strong>。</p>
<p>得到<code>[2], [1], [8], [6]</code>。现在我们完成了拆分过程，每个数组都是有序的。</p>
<p>接下来我们将数组两两归并排序，<code>[1, 2]</code>和<code>[6, 8]</code>。</p>
<p>继续将这两个数组合并最终得到<code>[1, 2, 6, 8]</code>。</p>
<h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>归并排序的复杂度 <code>nlogn</code>。这比我们之前的冒泡排序和选择排序 n<sup>2</sup>的复杂度好了很多。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/4VqmGXwpLqc" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="3-Quick-Sort-快速排序"><a href="#3-Quick-Sort-快速排序" class="headerlink" title="3. Quick Sort 快速排序"></a>3. Quick Sort 快速排序</h2><p>快速排序的原理是首先我们选择一个<code>中轴(pivot)</code>, 一般选择数组内的第一个值。然后有比中轴值小的元素位于中轴的左侧，而大于中轴值的元素位于中轴的右侧。最终实现有序的排序。</p>
<h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><p>给定一个数组 <code>a = [12, 25, 33, 5, 8]</code>。</p>
<p>选择第一个值<code>a[0]=44</code>为我们的中轴，并用<code>p</code>来记录。同时我们用变量<code>i</code>记录替换索引，<code>j</code>来记录遍历的索引。</p>
<p>我们的目标即在 j 的遍历过程中，如果 a[j]的值小于当前的中轴值，我们将 i 递增 1，然后将 a[i]和 a[j]进行调换。当 j 遍历完数组后，我们再将 a[i]与中轴调换位置。</p>
<p>起始我们的中轴<code>p = 12</code>, <code>i = 0</code>, <code>j = 1</code>。</p>
<table>
<thead>
<tr>
<th align="center">p 中轴</th>
<th align="center">i</th>
<th align="center">j</th>
<th align="center">a[j]</th>
<th align="center">Compare</th>
<th align="center">Procedure</th>
<th align="center">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">25</td>
<td align="center">25 &gt; 12</td>
<td align="center">不需要调换 递增 j</td>
<td align="center"><code>[12, 25, 33, 5, 8]</code></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">33</td>
<td align="center">33 &gt; 12</td>
<td align="center">不需要调换 递增 j</td>
<td align="center"><code>[12, 25, 33, 5, 8]</code></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5 &lt; 12</td>
<td align="center">递增 i i = 1 替换 a[i]和 a[j]的位置 递增 j</td>
<td align="center"><code>[12, 5, 33, 25, 8]</code></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8 &lt; 12</td>
<td align="center">递增 i i = 2 替换 a[i]和 a[j]的位置 递增 j</td>
<td align="center"><code>[12, 5, 8, 25, 33]</code></td>
</tr>
</tbody></table>
<p>现在第一个 iteration 完成，我们将中轴 p = 12 与 a[2]的位置替换</p>
<p>得到<code>[8, 5, 12, 25, 33]</code>。我们可以发现现在 12 的左边都是小于 12 的，而右边都是大于 12 的。也就是说我们接下来只要对左边和右边的部分进行相同的操作即可完成快速排序。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(array) - <span class="number">1</span></span><br><span class="line">    pivot = a[l]</span><br><span class="line">    s = l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l+<span class="number">1</span>, r+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; p:</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            a[s], a[i] = a[i], a[s]</span><br><span class="line">            a[l], a[s] = a[s], a[l]</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>快速排序的复杂度为<code>nlong(n)</code></p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/cnzIChso3cc" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h1 id="Transform-and-Conquer-变治法"><a href="#Transform-and-Conquer-变治法" class="headerlink" title="Transform and Conquer 变治法"></a>Transform and Conquer 变治法</h1><h2 id="1-Instance-Simplification-Pre-sorting-预排序"><a href="#1-Instance-Simplification-Pre-sorting-预排序" class="headerlink" title="1. Instance Simplification Pre-sorting 预排序"></a>1. Instance Simplification Pre-sorting 预排序</h2><h3 id="Check-Elements-Uniqueness-判断数组内元素是否重复"><a href="#Check-Elements-Uniqueness-判断数组内元素是否重复" class="headerlink" title="Check Elements Uniqueness 判断数组内元素是否重复"></a>Check Elements Uniqueness 判断数组内元素是否重复</h3><p>给出一个数组，判断是否该数组存在重复元素。</p>
<p>我们先用暴力求解来看下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique_bf</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 存储当前索引元素变量</span></span><br><span class="line">        index_value = array[i]</span><br><span class="line">        <span class="comment"># 循环数组 查找是否有匹配相等的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(array[j] == index_value):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>我们发现用暴力求解的算法得到复杂度为 n<sup>2</sup>。</p>
<p>假设我们先将数组进行排序得到一个<strong>有序数组</strong>，然后在进行判断是否存在重复元素。算法效率是否会有提升呢?</p>
<p>如果是一个有序数组，我们只需要查看<strong>一个元素</strong>是否跟它的<strong>下一个元素</strong>是否相等即可。比如<code>[2, 3, 3, 5]</code>。a[1] = a[2] 很明显得出数组存在重复元素。</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique_presort</span><span class="params">(array)</span>:</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    <span class="comment"># 假设我们先进行排序 比如利用之前比较高效的归并或者快速排序</span></span><br><span class="line">    array.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> array[i] == array[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>由于算法由两部分构成（预排序数组和遍历数组查看元素相等），所以其复杂度也应该为两部分：排序的复杂度加检查元素相等的复杂度。</p>
<p>我们在之前的分治法中发现归并排序和快速排序是目前相对有效的算法。假设我们的预排序使用归并算法，那么排序部分的复杂度即<code>nlogn</code></p>
<p>由于我们只有一个循环遍历判断元素相等，所以整体算法复杂度为 <code>nlogn + n</code></p>
<p>也就是 <code>nlogn</code></p>
<h3 id="Find-the-Mode-寻找众数"><a href="#Find-the-Mode-寻找众数" class="headerlink" title="Find the Mode 寻找众数"></a>Find the Mode 寻找众数</h3><blockquote>
<p>众数是出现在一组数据中最频繁的数。</p>
</blockquote>
<p>先来看下用暴力求解如何实现这个算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_mode_bf</span><span class="params">(array)</span>:</span></span><br><span class="line">  n = len(array)</span><br><span class="line">  <span class="comment"># 计数器字典 统计每个数字的频率</span></span><br><span class="line">  counter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    counter[array[i]] = counter.get(array[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  occurence = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> counter.items():</span><br><span class="line">    <span class="keyword">if</span> value &gt; occurence:</span><br><span class="line">      occurence = value</span><br><span class="line">      mode = key</span><br><span class="line">  <span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure>

<p>最坏的情况下我们的数组每个元素都只出现一次 <code>[1, 2, 3, 4, 5, 6]</code>。复杂度为 n<sup>2</sup></p>
<p>如果数组已经是一个有序数组，那么相同的元素在有序数组里都是相邻的。</p>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_mode_presort</span><span class="params">(array)</span>:</span></span><br><span class="line">    array.sort()  <span class="comment"># sort array</span></span><br><span class="line">    i = <span class="number">0</span>; freq = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(array):</span><br><span class="line">        temp_freq = <span class="number">1</span>; temp_mode = array[i]</span><br><span class="line">        <span class="keyword">while</span> i + temp_freq &lt; len(array) <span class="keyword">and</span> array[i+temp_freq] == temp_mode:</span><br><span class="line">            temp_freq += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp_freq &gt; freq:</span><br><span class="line">            freq = temp_freq; mode = temp_mode</span><br><span class="line">        i += temp_freq</span><br><span class="line">    <span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>算法复杂度可以得出：<code>nlog n + log n = nlog n</code></p>
<h2 id="2-Representation-Change-改变数据的表现形式"><a href="#2-Representation-Change-改变数据的表现形式" class="headerlink" title="2. Representation Change 改变数据的表现形式"></a>2. Representation Change 改变数据的表现形式</h2><p>除了对数组进行预处理外，我们还可以改变数据结构来提高算法效率。</p>
<h3 id="Heap-堆的定义"><a href="#Heap-堆的定义" class="headerlink" title="Heap 堆的定义"></a>Heap 堆的定义</h3><ul>
<li>堆的每个<strong>父节点</strong>(parent node)都<strong>大于或者等于</strong>它的子节点(child node)</li>
<li>堆按照<strong>从左往右</strong>的顺序依次每层铺满子元素。</li>
<li>在顶堆中，最大的元素为 Root 即根节点。</li>
</ul>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20161423.png?alt=media&token=b043f03e-bca9-4e6e-a758-f47cd244e4c3" width="60%" height="auto">

<h3 id="Heap-Implementation-堆的应用"><a href="#Heap-Implementation-堆的应用" class="headerlink" title="Heap Implementation 堆的应用"></a>Heap Implementation 堆的应用</h3><p>将下面的堆树转换为数组表达形式</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20162133.png?alt=media&token=59dd7b37-81c6-4c7b-a581-8d6829b88ca1" width="30%" height="auto">

<br>

<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20162142.png?alt=media&token=b6a265f0-24b1-4c66-b3f2-6453516e7b33" width="50%" height="auto">

<p>同理可以根据数组转化为堆树。从数组第一个元素开始，从左往右依次把每层铺满子元素。最后由上至下改变节点的位置以满足堆的性质。</p>
<h3 id="Heap-Insert-堆的插入"><a href="#Heap-Insert-堆的插入" class="headerlink" title="Heap Insert 堆的插入"></a>Heap Insert 堆的插入</h3><p>假设我们要把一个数值插入到一个堆中,如何来实现呢?</p>
<p>给定一个堆的排序 <code>[16, 15, 10, 14, 7, 9, 3, 2, 8 ,1]</code>，我们想要插入<code>17</code>到这个堆中</p>
<ol>
<li><p>首先把 17 插入到数组的最后一个位置中。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20162537.png?alt=media&token=d9fddb9a-d835-49de-9e45-258f7508d8b1" width="60%" height="auto">
</li>
<li><p>然后将 17 与它的父节点 7 进行比较。7 小于 17 不满足父节点大于子节点的特性，于是调换 7 和 17 的位置。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/311.png?alt=media&token=caec7593-c628-4168-9543-7f2bf56fc7fe" width="60%" height="auto">
</li>
<li><p>重复<strong>步骤 2</strong> 直到堆的性质得到满足。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20162907.png?alt=media&token=7433c13d-ad7d-4d06-8b94-54ae543cddf7" width="60%" height="auto">

</li>
</ol>
<br>

<h4 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>由于堆的高度为<code>log n</code>，所有堆的插入算法复杂度为<code>log n</code>。因为我们要检查每层是否都满足堆的性质。</p>
<h3 id="Heap-Delete-堆的删除"><a href="#Heap-Delete-堆的删除" class="headerlink" title="Heap Delete 堆的删除"></a>Heap Delete 堆的删除</h3><p>从堆中删除一个元素的实现方法为：</p>
<ol>
<li>交换根节点的元素与堆尾的位置(数组中头尾交换)</li>
<li>删除堆尾</li>
<li><strong>由上至下</strong>调整堆的结构 (与堆的插入：由下至上相反)<ul>
<li>如果不满足堆的性质就交换两个节点的值</li>
</ul>
</li>
</ol>
<p>比如我们之前的例子，<code>[17, 16, 10, 14, 15, 9, 3, 2, 8, 1, 7]</code>。我们想要删除根节点 17。按照上面的步骤来实现即</p>
<ol>
<li><p>替换 17 与 7 的位置</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/heapdelete1.png?alt=media&token=ee262f31-245a-4427-9b74-57169b2f16f8" width="60%" height="auto">
</li>
<li><p>删除 节点 17</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/heapdelete2.png?alt=media&token=8a4fe4c4-36de-4aa2-b616-b558faca9e81" width="60%" height="auto"></li>
<li><p>调整堆的结构，7 与 16 对比，不满足堆的性质调换位置</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/heapdelete3.png?alt=media&token=23f09c2b-55aa-42cd-9892-fddd268b18de" width="60%" height="auto"></li>
<li><p>重复步骤 3 直到堆完全满足定义</p>
</li>
</ol>
<h4 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>由于堆的高度为<code>log n</code>，所有堆的插入算法效率为<code>log n</code>。</p>
<h3 id="Heap-Sort-堆排序"><a href="#Heap-Sort-堆排序" class="headerlink" title="Heap Sort 堆排序"></a>Heap Sort 堆排序</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>构建堆树(heap implementation)</li>
<li>构建顶堆，即根元素为最大值。</li>
<li>堆顶和堆尾的值交换顺序，并删除交换后的堆尾元素。</li>
<li>调整堆的节点位置以满足堆的性质</li>
<li>重复 1，2，3 步骤。</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>堆排序效率为<code>n logn</code></p>
<h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><div class="video-container"><iframe src="https://www.youtube.com/embed/2DmK_H7IdTo" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h1 id="Space-and-Time-Trade-Offs-时空权衡"><a href="#Space-and-Time-Trade-Offs-时空权衡" class="headerlink" title="Space and Time Trade-Offs 时空权衡"></a>Space and Time Trade-Offs 时空权衡</h1><h2 id="1-Counting-Sort-计数排序"><a href="#1-Counting-Sort-计数排序" class="headerlink" title="1. Counting Sort 计数排序"></a>1. Counting Sort 计数排序</h2><h3 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h3><p>给定一个数组<code>A = [4, 1, 3, 4, 3]</code></p>
<ol>
<li>找到数组内的最大值和最小值，即 4 和 1，创建一个新的数组<code>C = []</code>用来记录每个数值的频率，长度为<code>4-1+1=4</code><img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/1.png?alt=media&token=141e933e-8bf6-4a92-82c9-90083ec50f37" width="50%" height="auto"></li>
<li>遍历数组<code>A</code>并将每个数值的频率记录到<code>C</code>数组中。<code>C</code>数组的索引对应<code>A</code>数组的值。<br>最终结果为<code>C = [1, 0, 2, 2]</code>。<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/2.png?alt=media&token=bbfbf382-5953-4d24-b83b-16af4c5cdd1d" width="50%" height="auto"></li>
<li>将<code>C</code>数组内容的元素递归两两相加。比如<code>1+0=2</code>然后<code>2+2=4</code>如此。<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/3.png?alt=media&token=390d9075-b58b-4eca-b59f-5b099c9d841a" width="50%" height="auto"></li>
<li>最后，从<code>A</code>数组最后一个值开始，找到<code>C</code>数组内对应的<strong>频率减一</strong>后得到相对应的新的索引。然后放到新的数组<code>S = []</code><br>比如我们从<code>A[4] = 3</code>开始， 3 在 Count 中对应的频率是 3，我们减一后得到 2，于是我们把 3 放在<code>S[2]</code>的位置。<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/4.png?alt=media&token=1c7f75dd-7f15-4d5f-a432-376f7c1fd1fa" width="50%" height="auto">
重复步骤 4 最后得到有序数组`[1, 3, 3, 4, 4]`

</li>
</ol>
<h3 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>整个算法过程中我们要遍历两个数组，一个是给定的数组，另一个为计算频率的数组。</p>
<p>所以最好的情况下算法复杂度为 n。这比我们之前的分治法快速排序和归并排序更有效。</p>
<h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/8uyB78HNR4M" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="2-Horspool’s-Algorithm-String-Matching-字符串匹配算法"><a href="#2-Horspool’s-Algorithm-String-Matching-字符串匹配算法" class="headerlink" title="2. Horspool’s Algorithm: String Matching 字符串匹配算法"></a>2. Horspool’s Algorithm: String Matching 字符串匹配算法</h2><p>在最开始的暴力求解部分中，我们介绍了如何使用暴力求解来进行字符串匹配的算法。</p>
<p>如果字符串不匹配，我们移动字符一个单位进行对比，重复该步骤直到遍历整个字符。我们也总结出时间复杂度为<code>(n-m+1)m</code>, n 为字符的长度，m 为我们要匹配的字符串长度。</p>
<p><code>Horspool</code>算法不同的是，当我们遇到 mismatch 也就是不匹配的情况，我们可以位移 1 个或者多个单位再进行比较。位移的多少取决于我们可以用一个<code>shift table</code>来表示。</p>
<h3 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h3><p>假设我们想要匹配的字符串为<code>IDIGDAB</code>。字符串的长度为<code>7</code>。进行匹配的字符为<code>IBAGHJDABADAB</code>。</p>
<p>每个字符的值为字符串中出现在最右侧的索引。即<code>m - index in pattern -1</code>。</p>
<p>比如 I 出现了两次，但最右侧的索引为 2, 那么 I 的位移为 <code>7 - 2 - 1 = 4</code>。</p>
<p>最后一个字母<code>B</code>因为没有出现过，所以唯一单位为字母的长度也就是 7</p>
<p>同理可以得出 shift table 如下</p>
<table>
<thead>
<tr>
<th align="center">Letters</th>
<th align="center">I</th>
<th align="center">D</th>
<th align="center">G</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">*</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Value</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">7</td>
<td align="center">7</td>
</tr>
</tbody></table>
<p>有了 Shift Table 之后我们可以进行匹配，一旦有字符不匹配，我们即可参照 shift table 进行相对应的字符移动。</p>
<p>首先<code>B</code>与<code>D</code>不匹配，根据 Shift Table, 我们需要将字符向右移动两个单位。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20174305.png?alt=media&token=083aa2a2-d97a-4bed-8efb-11004c845e94" width="50%" height="auto">

<p>现在<code>G</code>与<code>J</code>不匹配，由于<code>B</code>是我们字符串中比较的最后一个字符，所以我们参照<code>B</code>移动字符 7 个单位。然后重复步骤即可。<br><img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/12.png?alt=media&token=92bac8ce-f00d-4404-a172-c73b817fcb9b" width="50%" height="auto"></p>
<h2 id="3-Hash-哈希"><a href="#3-Hash-哈希" class="headerlink" title="3. Hash 哈希"></a>3. Hash 哈希</h2><h3 id="Hasing-Function-哈希函数"><a href="#Hasing-Function-哈希函数" class="headerlink" title="Hasing Function 哈希函数"></a>Hasing Function 哈希函数</h3><p>假设哈希表长度为 5, 可以利用哈希函数将元素的键利用余数来转换为整数键。</p>
<p>比如要把(Emily, 6046321)写入到哈希表中。</p>
<p>我们先把<code>Emily</code>每个字母利用<code>ord()</code>函数转换成相应的整数。</p>
<p><code>ord(e) + ord(m) + ord(i) + ord(l) + ord(y) = 5 + 13 + 9 + 12 + 25 = 64</code></p>
<p>因为哈希表的长度为 5，64 除以 5 的余数为 4, 也就是转换后<code>6046321</code>的键。</p>
<h3 id="Collision-Handling-冲突解决"><a href="#Collision-Handling-冲突解决" class="headerlink" title="Collision Handling 冲突解决"></a>Collision Handling 冲突解决</h3><p>如果在利用<code>哈希函数</code>转换键的时候出现相同的键怎么办呢? 比如两个元素 <code>Key mod 5</code>之后都是 4。如何解决这两个元素在哈希表中位置得问题呢？</p>
<h4 id="1-Separate-Chaining-分离链接"><a href="#1-Separate-Chaining-分离链接" class="headerlink" title="1. Separate Chaining 分离链接"></a>1. Separate Chaining 分离链接</h4><p>第一种方法是分离链接，也就是用链表的方式来将相同的键组合在一起。</p>
<p>比如给定哈希函数<code>h(i) = i mod 7</code>, 将下面的键值写入到哈希表中</p>
<table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">Values</th>
</tr>
</thead>
<tbody><tr>
<td align="center">44</td>
<td align="center">name1</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">name2</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">name3</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">name4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">name5</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">name6</td>
</tr>
</tbody></table>
<p>我们可以发现<code>44</code>, <code>23</code>, 以及<code>16</code>的 key 都是相同的，那么我们就可以用链表的方式把这它们连接起来。最后得到的哈希表如下。</p>
<p>h(44) = 44 mod 7 = 2<br>h(23) = 23 mod 7 = 2<br>h(16) = 23 mod 7 = 2</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20202615.png?alt=media&token=c720646f-7ef4-463b-a407-dbce665c6256" width="70%" height="auto">

<br>

<h4 id="2-Closed-Hashing-封闭散列"><a href="#2-Closed-Hashing-封闭散列" class="headerlink" title="2. Closed Hashing 封闭散列"></a>2. Closed Hashing 封闭散列</h4><p>封闭散列解决冲突的方式为如果有冲突，向后找是否有空缺的位置并把键值写入到该位置。</p>
<p>我们用之前相同的例子，但是这次用封闭散列来解决冲突问题。</p>
<p>首先转换所有键</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h(44) = 2</span><br><span class="line">h(12) = 5</span><br><span class="line">h(23) = 2</span><br><span class="line">h(16) = 2</span><br><span class="line">h(5) = 5</span><br><span class="line">h(28) = 0</span><br></pre></td></tr></table></figure>

<p>然后依次写入到哈希表中，name3 和 name1 都是相同键，但是 index 2 已经没有位置，所以我们把 name3 放到 index3 的位置。同理其他键值最后得到哈希表如下:</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">Values</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">name6</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">name1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">name3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">name4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">name2</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">name5</td>
</tr>
</tbody></table>
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h2 id="4-Summary-of-sorting-algorithms-排序算法总结"><a href="#4-Summary-of-sorting-algorithms-排序算法总结" class="headerlink" title="4. Summary of sorting algorithms 排序算法总结"></a>4. Summary of sorting algorithms 排序算法总结</h2><table>
<thead>
<tr>
<th>算法</th>
<th>最好的情况</th>
<th>最坏的情况</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>n2</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>n</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>n</td>
<td>n2</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>n logn</td>
<td>n logn</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>n logn</td>
<td>n2</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>n logn</td>
<td>n logn</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>n</td>
<td>n + u</td>
<td>不稳定</td>
</tr>
</tbody></table>
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h1 id="Data-Structure-数据结构"><a href="#Data-Structure-数据结构" class="headerlink" title="Data Structure 数据结构"></a>Data Structure 数据结构</h1><blockquote>
<p>数据结构是用来管理和储存数据的一种方式</p>
</blockquote>
<h2 id="1-Linear-Data-Structure-线性数据结构"><a href="#1-Linear-Data-Structure-线性数据结构" class="headerlink" title="1. Linear Data Structure 线性数据结构"></a>1. Linear Data Structure 线性数据结构</h2><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h3><p>一个数组通常有一系列相同类型的元素组成，每个元素都有相对应的索引值。</p>
<p>比如下面<code>arr_list</code>数组，<code>item one</code>对应的索引值就是 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr_list = [<span class="string">'item one'</span>, <span class="string">'item two'</span>, <span class="string">'item three'</span>]</span><br></pre></td></tr></table></figure>

<p>由于数组的长度需要预先决定来分配内存。所以对于长度明确，或者插入删除不频繁的数据，数组比较适合。但如果数据需要频发插入或者删除，那我们可以用其他的数据结构。</p>
<h3 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List 链表"></a>Linked List 链表</h3><p>链表由 0 或者多个叫做节点的元素组成，每个节点都有一个指针指向下一个节点。</p>
<p>在数组中，如果想要拿到索引为 2 的值，可以直接用 arr[2]。但是在链表中，我们要从<code>head</code>开始一直往右进行节点的查找。</p>
<p><strong>单向链表</strong></p>
<p>单向链表，即每个节点中有一个指针指向后继节点。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/linkedlist.png?alt=media&token=069ba69f-0b49-48d0-a353-5002b821f1cf" width="70%" height="auto">
<br>

<p><strong>双向链表</strong></p>
<p>双向链表，每个节点中有两个指针并分别指向前驱和后继。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/linkedlist2.png?alt=media&token=cfaf0918-27ee-49ef-9249-c0d3f81c6c22" width="70%" height="auto">
<br>

<h4 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>Search: <code>O(n)</code></li>
<li>Insert: <code>O(1)</code></li>
<li>Delete: <code>O(1)</code></li>
</ul>
<h3 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h3><p>遵循<code>后进先出(LIFO)</code>原则, 可以想象一叠盘子，你每清理完一个碟子你往上叠。结束后你从最上面的开始一个一个回收。最后一个清洁的碟子也是第一个拿走的。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/stack.png?alt=media&token=3d248a10-e203-4e05-9783-a2b619889ab8" width="70%" height="auto">
<br>

<p>插入方法为<code>push</code>，删除方法为<code>pop</code>。</p>
<h4 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>Search: <code>O(n)</code></li>
<li>Insert: <code>O(1)</code></li>
<li>Delete: <code>O(1)</code></li>
</ul>
<h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h3><p>跟栈相反，队列遵循先进先出原则。可以想象以下我们平常超市购物结账排队的时候。排在第一位置的人也是先结完账最先离开的。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/Introduction.png?alt=media&token=d5dc1f40-5d9a-44b2-94c9-01c0490fab75" width="50%" height="auto">
<br>

<h4 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>Search: <code>O(n)</code></li>
<li>Insert: <code>O(1)</code></li>
<li>Delete: <code>O(1)</code></li>
</ul>
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h2 id="2-Non-Linear-Data-Structures-Graph-图"><a href="#2-Non-Linear-Data-Structures-Graph-图" class="headerlink" title="2. Non-Linear Data Structures: Graph 图"></a>2. Non-Linear Data Structures: Graph 图</h2><h3 id="Types-图的分类"><a href="#Types-图的分类" class="headerlink" title="Types 图的分类"></a>Types 图的分类</h3><p>图又可分为有向图和无向图</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20122800.png?alt=media&token=a82cd4fb-63c0-4927-88c9-f3e7ffe13c64" width="70%" height="auto">

<h3 id="Representing-Graphs-图的表达方式"><a href="#Representing-Graphs-图的表达方式" class="headerlink" title="Representing Graphs 图的表达方式"></a>Representing Graphs 图的表达方式</h3><img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20123400.png?alt=media&token=45ef871a-d7a2-465d-aa06-558c07a4acb8" width="50%" height="auto">

<h4 id="1-Adjacency-Matrix-邻接矩阵"><a href="#1-Adjacency-Matrix-邻接矩阵" class="headerlink" title="1. Adjacency Matrix 邻接矩阵"></a>1. Adjacency Matrix 邻接矩阵</h4><p>用一个 2D 数组来储存图中顶点间的关系数据。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20123411.png?alt=media&token=4d49cadd-470a-4144-9eb9-75a662fa8de7" width="50%" height="auto">

<h4 id="2-Adjacency-Lists-邻接表"><a href="#2-Adjacency-Lists-邻接表" class="headerlink" title="2. Adjacency Lists 邻接表"></a>2. Adjacency Lists 邻接表</h4><p>用来记录每一个节点所连接的所有其他节点。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20123423.png?alt=media&token=e060e48e-5d26-4938-bacd-b6140111f128" width="50%" height="auto">

<h3 id="Graph-Traversal-图的遍历"><a href="#Graph-Traversal-图的遍历" class="headerlink" title="Graph Traversal 图的遍历"></a>Graph Traversal 图的遍历</h3><h4 id="1-Depth-First-Search-DFS-深度优先搜索"><a href="#1-Depth-First-Search-DFS-深度优先搜索" class="headerlink" title="1. Depth-First Search (DFS) 深度优先搜索"></a>1. Depth-First Search (DFS) 深度优先搜索</h4><img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/DFS.png?alt=media&token=b19c9461-5ea7-4a02-83d5-97f59227dec3" width="50%" height="auto">

<p>DFS 我们随意选择一个起点然后进行其他节点的探索，直到所有的节点全部被探索过。</p>
<p>比如我们从 a 开始，我们现在可以走<code>b</code>, <code>f</code>, 或者<code>e</code>。我们用字母升序选择<code>b</code>，然后<code>f</code>最后<code>e</code>。</p>
<p>这个时候已经没有路可以走了。那我们就要往回走到<code>b</code>。然后继续<code>g -&gt; c -&gt; d -&gt; h</code></p>
<p>最后 DFS 的遍历为<code>abfegcdh</code> 如下图所示。当然如果一开始我们走完 a 选择其他路线，那 DFS 的遍历结果也是不一样的。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/d'f's%E6%89%B9%E6%B3%A8%202020-07-20%20210327.png?alt=media&token=b7bdde72-f3e2-4d8b-89ae-c3d669bc2543" width="50%" height="auto">

<h4 id="2-Breadth-First-Search-BFS-广度优先搜素"><a href="#2-Breadth-First-Search-BFS-广度优先搜素" class="headerlink" title="2. Breadth-First Search (BFS) 广度优先搜素"></a>2. Breadth-First Search (BFS) 广度优先搜素</h4><p>广度优先搜索则是先把每个节点所有可行路线都走一遍，然后再回到每个子节点进行搜索。</p>
<p>现在我们用 BFS 遍历之前的例子。</p>
<p>我们从 a 开始，这时候有 b, e, f。然后 a 已经遍历完。我们开始遍历 b，发现只有 g。g 遍历完 c 和 h 后只剩下 d。</p>
<p>得到 BFS <code>abefgchd</code></p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/BFS.png?alt=media&token=b7229ee9-55ad-479e-8acd-d1fae3464353" width="50%" height="auto">

<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->
<!------------------------------------ 分割线 ---------------------------------------->

<h1 id="Greedy-Approach-贪心算法"><a href="#Greedy-Approach-贪心算法" class="headerlink" title="Greedy Approach 贪心算法"></a>Greedy Approach 贪心算法</h1><h2 id="1-Prim’s-Algorithm-普林姆算法"><a href="#1-Prim’s-Algorithm-普林姆算法" class="headerlink" title="1. Prim’s Algorithm 普林姆算法"></a>1. Prim’s Algorithm 普林姆算法</h2><p>在普林姆算法中，我们随意选择一个起点，之后每次都选择访问个节点的最短的路线，直到所有的节点都被访问过。</p>
<h3 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h3><img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/prim.png?alt=media&token=dde1bf4c-bfce-47b0-b6f7-c72f4373ce74" width="60%" height="auto">

<p>我们从 a 开始，可以发现最短路径为<code>af</code>，所以我们连接<code>af</code>。现在找到所有与 a 和 f 相连的节点的最短路径，我们找到<code>fe</code>最短, 连接<code>fe</code>。</p>
<p>这个时候<code>ae</code>是最短的，但是<code>a</code>和<code>e</code>都已经访问过了，所以我们不能选择这条路径。</p>
<p>于是我们连接<code>eb</code>, 然后<code>bc</code>最后<code>cd</code>结束得到最小生成树。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20212525.png?alt=media&token=e173c8f3-b841-4052-922e-007faa4de91a" width="50%" height="auto">

<h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/cplfcGZmX7I" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="2-Kruskal’s-Algorithm-克鲁斯卡尔算法"><a href="#2-Kruskal’s-Algorithm-克鲁斯卡尔算法" class="headerlink" title="2. Kruskal’s Algorithm 克鲁斯卡尔算法"></a>2. Kruskal’s Algorithm 克鲁斯卡尔算法</h2><p>与 Prim 算法不同的时，Kruskal 算法我们不是随意选择一个起点，而是先选择图中最短的一条路径，然后在不制造出 cycle 的情况下，找到所有最短的路线直到所有节点被访问。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/prim.png?alt=media&token=dde1bf4c-bfce-47b0-b6f7-c72f4373ce74" width="60%" height="auto">

<p>同样用这个图，我们这次从<code>fe</code>开始，然后同样最短的路径有<code>af</code>和<code>cd</code>都为 4，可以都连接。</p>
<p>这个时候<code>ae</code>不能连接因为会出现<code>cycle</code>。</p>
<p>所以我们连接下一个最短路径<code>bc</code>。之后时<code>be</code>。于是得到最小生成树如下所示，可以发现跟 Prim 算法的结果相同。</p>
<img src= "/img/loading.gif" data-src="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/%E6%89%B9%E6%B3%A8%202020-07-20%20212525.png?alt=media&token=e173c8f3-b841-4052-922e-007faa4de91a" width="50%" height="auto">

<div class="video-container"><iframe src="https://www.youtube.com/embed/71UQH7Pr9kU" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="3-Dijkstra’s-Algorithm-迪克斯特拉算法"><a href="#3-Dijkstra’s-Algorithm-迪克斯特拉算法" class="headerlink" title="3. Dijkstra’s Algorithm: 迪克斯特拉算法"></a>3. Dijkstra’s Algorithm: 迪克斯特拉算法</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/_lHSawdgXpI" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Yang Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yangblog.netlify.app/2020/06/15/10-common-algo-review/">https://yangblog.netlify.app/2020/06/15/10-common-algo-review/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yangblog.netlify.app" target="_blank">Yang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/notes/">notes</a><a class="post-meta__tags" href="/tags/algorithim/">algorithim</a></div><div class="post_share"><div class="social-share" data-image="https://firebasestorage.googleapis.com/v0/b/yangliweb.appspot.com/o/6038586442907648.png?alt=media&amp;token=e6fd07e9-bb9a-45ab-999f-256e874132fa" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/17/11-es6-notes/"><img class="prev-cover" data-src="https://miro.medium.com/max/840/0*Vbp13RW_9HpRqH6E.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ES6与Javascrpit的对比</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/15/09-customize-powershell/"><img class="next-cover" data-src="https://i1.wp.com/regroove.ca/wp-content/uploads/2018/08/powershell.png?fit=2560%2C1440&amp;ssl=1" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">自定义Windows10下的terminal外观</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/12/07-typescript/" title="Typescript 让你的Javascript更严谨"><img class="relatedPosts_cover" data-src="https://miro.medium.com/max/816/1*mn6bOs7s6Qbao15PMNRyOA.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-12</div><div class="relatedPosts_title">Typescript 让你的Javascript更严谨</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/14/08-your-first-npm-package/" title="如何创建你的第一个React组件库并发布到npm"><img class="relatedPosts_cover" data-src="https://www.itprotoday.com/sites/itprotoday.com/files/styles/article_featured_retina/public/github-npm.png?itok=NVoj-tk8"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-14</div><div class="relatedPosts_title">如何创建你的第一个React组件库并发布到npm</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/17/11-es6-notes/" title="ES6与Javascrpit的对比"><img class="relatedPosts_cover" data-src="https://miro.medium.com/max/840/0*Vbp13RW_9HpRqH6E.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-17</div><div class="relatedPosts_title">ES6与Javascrpit的对比</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/18/13-userRef-useReduce/" title="React常用Hooks笔记"><img class="relatedPosts_cover" data-src="https://www.educative.io/api/page/6018530514305024/image/download/5753173610332160"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-18</div><div class="relatedPosts_title">React常用Hooks笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/20/15-data-comm/" title="数据通信课程笔记"><img class="relatedPosts_cover" data-src="https://wallpaperplay.com/walls/full/b/1/e/42765.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-20</div><div class="relatedPosts_title">数据通信课程笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/20/16-angular/" title="Angular框架学习笔记"><img class="relatedPosts_cover" data-src="https://www.freecodecamp.org/news/content/images/2020/04/Copy-of-Copy-of-Travel-Photography.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-20</div><div class="relatedPosts_title">Angular框架学习笔记</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://3.bp.blogspot.com/-bsAe5iHfUvw/XMm2l8YCMtI/AAAAAAAAA28/9-Uj-v3GHhIE06c1_HdSEOeXML1byHInACLcBGAs/s1600/what-is-an-algorithm.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Yang Li</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">( •̀ ω •́ )✧</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>